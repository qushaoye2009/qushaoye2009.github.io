<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>使用vue开发PC端应用 | 青颖科技</title>
    <meta name="description" content="技术，提升生活的幸福感和创造力！">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="favicon.ico">
  <meta name="theme-color" content="#3eaf7c">
    
    <link rel="preload" href="/blog/assets/css/0.styles.4738fa7e.css" as="style"><link rel="preload" href="/blog/assets/js/app.2c917b5d.js" as="script"><link rel="preload" href="/blog/assets/js/2.fd5fecfd.js" as="script"><link rel="preload" href="/blog/assets/js/29.847049dd.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.1942694b.js"><link rel="prefetch" href="/blog/assets/js/11.fc70bb5f.js"><link rel="prefetch" href="/blog/assets/js/12.c3fac9da.js"><link rel="prefetch" href="/blog/assets/js/13.57136e29.js"><link rel="prefetch" href="/blog/assets/js/14.82c42e18.js"><link rel="prefetch" href="/blog/assets/js/15.c9ad5910.js"><link rel="prefetch" href="/blog/assets/js/16.54614957.js"><link rel="prefetch" href="/blog/assets/js/17.68526e2c.js"><link rel="prefetch" href="/blog/assets/js/18.523511fe.js"><link rel="prefetch" href="/blog/assets/js/19.adb148b4.js"><link rel="prefetch" href="/blog/assets/js/20.832cdccc.js"><link rel="prefetch" href="/blog/assets/js/21.dc5838dc.js"><link rel="prefetch" href="/blog/assets/js/22.24b2e047.js"><link rel="prefetch" href="/blog/assets/js/23.395e8337.js"><link rel="prefetch" href="/blog/assets/js/24.bcd0d929.js"><link rel="prefetch" href="/blog/assets/js/25.31ef45a8.js"><link rel="prefetch" href="/blog/assets/js/26.33cde361.js"><link rel="prefetch" href="/blog/assets/js/27.2bebb811.js"><link rel="prefetch" href="/blog/assets/js/28.81a1225e.js"><link rel="prefetch" href="/blog/assets/js/3.03c85107.js"><link rel="prefetch" href="/blog/assets/js/30.99874fba.js"><link rel="prefetch" href="/blog/assets/js/31.a1519bdb.js"><link rel="prefetch" href="/blog/assets/js/32.57884a16.js"><link rel="prefetch" href="/blog/assets/js/33.48d74260.js"><link rel="prefetch" href="/blog/assets/js/34.e8b94efe.js"><link rel="prefetch" href="/blog/assets/js/35.a094d0aa.js"><link rel="prefetch" href="/blog/assets/js/36.657cb6a4.js"><link rel="prefetch" href="/blog/assets/js/37.311e8110.js"><link rel="prefetch" href="/blog/assets/js/38.497cf9a6.js"><link rel="prefetch" href="/blog/assets/js/39.da027a3c.js"><link rel="prefetch" href="/blog/assets/js/4.4e078781.js"><link rel="prefetch" href="/blog/assets/js/40.89e258b5.js"><link rel="prefetch" href="/blog/assets/js/41.b10f4b3c.js"><link rel="prefetch" href="/blog/assets/js/42.d14aedd7.js"><link rel="prefetch" href="/blog/assets/js/43.e7524932.js"><link rel="prefetch" href="/blog/assets/js/44.06760ba2.js"><link rel="prefetch" href="/blog/assets/js/45.731ffc94.js"><link rel="prefetch" href="/blog/assets/js/46.f3f0f681.js"><link rel="prefetch" href="/blog/assets/js/47.d8c6b691.js"><link rel="prefetch" href="/blog/assets/js/48.a18908ef.js"><link rel="prefetch" href="/blog/assets/js/49.f05a4ac1.js"><link rel="prefetch" href="/blog/assets/js/5.27199e80.js"><link rel="prefetch" href="/blog/assets/js/50.7da410d2.js"><link rel="prefetch" href="/blog/assets/js/51.040d2bcd.js"><link rel="prefetch" href="/blog/assets/js/52.38f79a21.js"><link rel="prefetch" href="/blog/assets/js/53.d862fdda.js"><link rel="prefetch" href="/blog/assets/js/54.123a3dbf.js"><link rel="prefetch" href="/blog/assets/js/55.30941e0e.js"><link rel="prefetch" href="/blog/assets/js/56.687d4549.js"><link rel="prefetch" href="/blog/assets/js/57.1da8ee53.js"><link rel="prefetch" href="/blog/assets/js/58.07d4b9b2.js"><link rel="prefetch" href="/blog/assets/js/59.85be68d0.js"><link rel="prefetch" href="/blog/assets/js/6.c8690ffb.js"><link rel="prefetch" href="/blog/assets/js/60.b1eae672.js"><link rel="prefetch" href="/blog/assets/js/61.cf8eb291.js"><link rel="prefetch" href="/blog/assets/js/62.8a4c84df.js"><link rel="prefetch" href="/blog/assets/js/63.e24c018d.js"><link rel="prefetch" href="/blog/assets/js/64.6513064e.js"><link rel="prefetch" href="/blog/assets/js/65.909b57b7.js"><link rel="prefetch" href="/blog/assets/js/66.ebb4a0c5.js"><link rel="prefetch" href="/blog/assets/js/67.a170079c.js"><link rel="prefetch" href="/blog/assets/js/68.44856acf.js"><link rel="prefetch" href="/blog/assets/js/69.e2f35931.js"><link rel="prefetch" href="/blog/assets/js/7.67070ebe.js"><link rel="prefetch" href="/blog/assets/js/70.18454790.js"><link rel="prefetch" href="/blog/assets/js/71.0d37750b.js"><link rel="prefetch" href="/blog/assets/js/72.1508d391.js"><link rel="prefetch" href="/blog/assets/js/73.ad3a0e1d.js"><link rel="prefetch" href="/blog/assets/js/74.0bd7a766.js"><link rel="prefetch" href="/blog/assets/js/75.685f7337.js"><link rel="prefetch" href="/blog/assets/js/76.fa3b118b.js"><link rel="prefetch" href="/blog/assets/js/77.3441fc95.js"><link rel="prefetch" href="/blog/assets/js/8.5f3265b2.js"><link rel="prefetch" href="/blog/assets/js/9.c921ff13.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.4738fa7e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">青颖科技</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分享" class="dropdown-title"><span class="title">分享</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/share/interview.html" class="nav-link">
  如何面试前端
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/java.html" class="nav-link">
  java面试题
</a></li><li class="dropdown-item"><!----> <a href="/blog/job/sf.html" class="nav-link">
  前端面试题
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/env.html" class="nav-link">
  开发环境配置参考
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/opt.html" class="nav-link">
  web应用性能优化
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/uni.html" class="nav-link">
  uni-app多端开发回顾
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/koa.html" class="nav-link">
  koa+vue全栈开发实战
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/webpack.html" class="nav-link">
  深入webpack
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/webpack-vue.html" class="nav-link">
  webpack配置vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/md.html" class="nav-link">
  markdown语法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文字教程" class="dropdown-title"><span class="title">文字教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/fs/1.html" class="nav-link">
  JS全栈培训
</a></li><li class="dropdown-item"><!----> <a href="/blog/static/1_1.html" class="nav-link">
  全栈入门
</a></li><li class="dropdown-item"><!----> <a href="/blog/js/1.html" class="nav-link">
  JS入门教程
</a></li><li class="dropdown-item"><!----> <a href="/blog/dd/1-3.html" class="nav-link">
  JS高级程序设计
</a></li><li class="dropdown-item"><!----> <a href="/blog/fe/vue.html" class="nav-link">
  前端高级知识技能
</a></li><li class="dropdown-item"><!----> <a href="/blog/en/ecma.html" class="nav-link">
  必知编程英文词汇
</a></li></ul></div></div><div class="nav-item"><a href="https://adeqing.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他链接" class="dropdown-title"><span class="title">其他链接</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/url/fe.html" class="nav-link">
  常用网址
</a></li><li class="dropdown-item"><!----> <a href="/blog/url/review.html" class="nav-link">
  面试复习
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/qushaoye2009" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分享" class="dropdown-title"><span class="title">分享</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/share/interview.html" class="nav-link">
  如何面试前端
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/java.html" class="nav-link">
  java面试题
</a></li><li class="dropdown-item"><!----> <a href="/blog/job/sf.html" class="nav-link">
  前端面试题
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/env.html" class="nav-link">
  开发环境配置参考
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/opt.html" class="nav-link">
  web应用性能优化
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/uni.html" class="nav-link">
  uni-app多端开发回顾
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/koa.html" class="nav-link">
  koa+vue全栈开发实战
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/webpack.html" class="nav-link">
  深入webpack
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/webpack-vue.html" class="nav-link">
  webpack配置vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/share/md.html" class="nav-link">
  markdown语法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文字教程" class="dropdown-title"><span class="title">文字教程</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/fs/1.html" class="nav-link">
  JS全栈培训
</a></li><li class="dropdown-item"><!----> <a href="/blog/static/1_1.html" class="nav-link">
  全栈入门
</a></li><li class="dropdown-item"><!----> <a href="/blog/js/1.html" class="nav-link">
  JS入门教程
</a></li><li class="dropdown-item"><!----> <a href="/blog/dd/1-3.html" class="nav-link">
  JS高级程序设计
</a></li><li class="dropdown-item"><!----> <a href="/blog/fe/vue.html" class="nav-link">
  前端高级知识技能
</a></li><li class="dropdown-item"><!----> <a href="/blog/en/ecma.html" class="nav-link">
  必知编程英文词汇
</a></li></ul></div></div><div class="nav-item"><a href="https://adeqing.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他链接" class="dropdown-title"><span class="title">其他链接</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/url/fe.html" class="nav-link">
  常用网址
</a></li><li class="dropdown-item"><!----> <a href="/blog/url/review.html" class="nav-link">
  面试复习
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/qushaoye2009" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JS全栈培训</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/fs/1.html" class="sidebar-link">从零打造个人博客和简历</a></li><li><a href="/blog/fs/2.html" class="active sidebar-link">使用vue开发PC端应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_01-课程简介" class="sidebar-link">01 课程简介</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_1-1-pc端、web端、桌面端、移动端区别" class="sidebar-link">1.1 pc端、web端、桌面端、移动端区别</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_1-2-为何使用框架？" class="sidebar-link">1.2 为何使用框架？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_1-3-框架和设计模式" class="sidebar-link">1.3 框架和设计模式</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_1-4-前后端分离" class="sidebar-link">1.4 前后端分离</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_1-5-使用前端框架解决了哪些问题？" class="sidebar-link">1.5 使用前端框架解决了哪些问题？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_1-6-如何挑选适合的前端框架？" class="sidebar-link">1.6 如何挑选适合的前端框架？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_1-7-什么vue-js？" class="sidebar-link">1.7 什么Vue.js？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_1-8-为何使用vue" class="sidebar-link">1.8 为何使用vue?</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_02-初始化项目" class="sidebar-link">02 初始化项目</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_2-1-什么是前端脚手架？" class="sidebar-link">2.1 什么是前端脚手架？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_2-2-使用-vue-cli-初始化项目" class="sidebar-link">2.2 使用 vue-cli 初始化项目</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_03-vue基础用法" class="sidebar-link">03 vue基础用法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_3-1-什么是单文件组件" class="sidebar-link">3.1 什么是单文件组件</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_3-2-export-defalut-后面的对象的理解" class="sidebar-link">3.2 export defalut 后面的对象的理解</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_3-3-v-if-和-v-show" class="sidebar-link">3.3 v-if 和 v-show</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_3-4-用-v-for-把一个数组对应为一组元素" class="sidebar-link">3.4 用 v-for 把一个数组对应为一组元素</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_3-5-v-for-与-v-if-一同使用" class="sidebar-link">3.5 v-for 与 v-if 一同使用</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_3-6-事件处理" class="sidebar-link">3.6 事件处理</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_3-7-表单输入绑定" class="sidebar-link">3.7 表单输入绑定</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_3-8-生命周期函数" class="sidebar-link">3.8 生命周期函数</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_04-官方的扩展库" class="sidebar-link">04 官方的扩展库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_4-1-vue-router" class="sidebar-link">4.1 vue-router</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_4-2-vuex" class="sidebar-link">4.2 vuex</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_05-使用axios请求数据" class="sidebar-link">05 使用axios请求数据</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_5-1-axios-有哪些特性？" class="sidebar-link">5.1 Axios 有哪些特性？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_5-2-使用axios" class="sidebar-link">5.2 使用axios</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_5-3-添加vue-config-js" class="sidebar-link">5.3 添加vue.config.js</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_06-参与开发视频网站" class="sidebar-link">06 参与开发视频网站</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_07-参与开发后台系统" class="sidebar-link">07 参与开发后台系统</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_08-模拟面试" class="sidebar-link">08 模拟面试</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-1-如何让css只在当前组件中起作用" class="sidebar-link">8.1 如何让CSS只在当前组件中起作用?</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-2-vue项目如何适配移动端？" class="sidebar-link">8.2 vue项目如何适配移动端？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-3-v-if和v-show的异同" class="sidebar-link">8.3 v-if和v-show的异同?</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-4-组件之间的如何传值？" class="sidebar-link">8.4 组件之间的如何传值？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-5-页面如何跳转？" class="sidebar-link">8.5 页面如何跳转？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-6-vue-cli中怎样使用自定义的组件？" class="sidebar-link">8.6 vue-cli中怎样使用自定义的组件？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-7-请谈谈vue生命周期钩子函数" class="sidebar-link">8.7 请谈谈Vue生命周期钩子函数?</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-8-谈谈-keep-alive" class="sidebar-link">8.8 谈谈 keep-alive?</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-9-在vue中如何使用插件？" class="sidebar-link">8.9 在vue中如何使用插件？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-10-为什么使用key？" class="sidebar-link">8.10 为什么使用key？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-11-为什么避免-v-if-和-v-for-用在一起？" class="sidebar-link">8.11 为什么避免 v-if 和 v-for 用在一起？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-12-怎么使用vuex？" class="sidebar-link">8.12 怎么使用vuex？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-13-vuex的state特性" class="sidebar-link">8.13 vuex的State特性</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-14-vuex的getter特性" class="sidebar-link">8.14 vuex的Getter特性</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-15-不用vuex会带来什么问题？" class="sidebar-link">8.15 不用vuex会带来什么问题？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-16-怎么定义vue-router的动态路由以及如何获取传过来的动态参数？" class="sidebar-link">8.16 怎么定义vue-router的动态路由以及如何获取传过来的动态参数？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-17-vue-loader是什么？使用它的用途有哪些？" class="sidebar-link">8.17 vue-loader是什么？使用它的用途有哪些？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-18-请说出vue-cli项目中src目录每个文件夹和文件的用法？" class="sidebar-link">8.18 请说出vue.cli项目中src目录每个文件夹和文件的用法？</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-19-vue数据双向绑定的实现原理" class="sidebar-link">8.19 vue数据双向绑定的实现原理</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-20-vue-为何用-proxy代替-defineproperty" class="sidebar-link">8.20 vue 为何用 proxy代替 defineProperty</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-21-vue-最新为何使用function-base-api-而不是class-api" class="sidebar-link">8.21 vue 最新为何使用function base api 而不是class api?</a></li><li class="sidebar-sub-header"><a href="/blog/fs/2.html#_8-22-vue-vs-react" class="sidebar-link">8.22 vue vs react</a></li></ul></li></ul></li><li><a href="/blog/fs/3.html" class="sidebar-link">使用uni-app开发移动端应用</a></li><li><a href="/blog/fs/4.html" class="sidebar-link">使用nodejs开发接口服务</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="使用vue开发pc端应用"><a href="#使用vue开发pc端应用" class="header-anchor">#</a> 使用vue开发PC端应用</h1> <p>通过第一个系列课的学习，多数同学已经入门JS全栈开发了，但在实际工作中，我们还是要熟练掌握一些主流的框架来提高我们的工作效率，于是我们基于vue这个主流的前端框架和我们公司实际的项目，带领大家从零开发一个PC端的视频学习网站和后台管理系统。</p> <p>对应的视频教程请访问： <a href="http://t.yibiankeji.com/" target="_blank" rel="noopener noreferrer">http://t.yibiankeji.com/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h2 id="_01-课程简介"><a href="#_01-课程简介" class="header-anchor">#</a> 01 课程简介</h2> <p>本节课我们主要讲解一些web开发的常识，以及整个系列课的安排。</p> <h3 id="_1-1-pc端、web端、桌面端、移动端区别"><a href="#_1-1-pc端、web端、桌面端、移动端区别" class="header-anchor">#</a> 1.1 pc端、web端、桌面端、移动端区别</h3> <p>PC就是个人电脑，PC端的应用指的是电脑上的客户端，如office、photoshop等不需要打开浏览器就可以直接运行的软件。</p> <p>WEB字面意思是网络，指的是需要连接网络才可以使用的应用，严格区分的话就是基于浏览器才可以访问的应用，如淘宝、天猫、京东等网站。</p> <p>而桌面端，通常指的是PC电脑的桌面，运行在Mac系统、window系统或者Linux系统上的不是基于浏览器的应用，一般开发Windows的桌面应用使用的是微软的.net技术，而开发Mac桌面应用则基于Xcode，后来企业为了降低成本，使用跨桌面端的开发技术，如electron.js, flutter等技术。</p> <p>移动端应用就更好理解了，只不过移动端的范围比较广，像常见的手机、平板、到现在的智能手表、运行在可穿戴设备上的一些应用程序都可以称之为移动端应用，考虑到很多智能设备不是很成熟，包括移动操作系统（主流的andriod、ios）的适配问题，移动端主要以手机为主。</p> <p>这是随着IT和互联网技术发展而不断演进的，移动端是随着2012后移动互联网的兴起才出现的，移动互联网目的是让我们随时随地的获取和发布信息。为了达到以上的目的，直接以浏览器作为入口，把应用程序运行在浏览器中。</p> <p>移动端应用虽然方便，但受限于界面，不适合操作复杂的流程。</p> <p>只要是web应用，对于用户来说，只是载体上的差别，功能性上两者没有大的区别。一个在手机上使用，一个在电脑上使用，手机更快捷。</p> <h3 id="_1-2-为何使用框架？"><a href="#_1-2-为何使用框架？" class="header-anchor">#</a> 1.2 为何使用框架？</h3> <p>框架是应用程序“模板”，就好比“八股”文章，不论好坏，按照规则填填就是。也可以说是“套路”，当你完成了一、二个项目后，你是不会放弃承载着你大量心血的“代码集”的，你会在第三、第四...个项目中重复你的思路、代码，当然也包括改进或创新，于是，“框架”出现了......</p> <p>我们现在通常说的框架， 都是一些牛人前辈或是对牛人前辈的总结而出的一套解决方案。 做程序。谁都知道。 经验最重要。所以好处就不言而喻。 我个人觉得他还有一个最大的好处在于。一个著名的框架，大家都用。</p> <p>每个人都熟悉这个框架的结构， 这样交流起来， 或者日后维护起来都非常方便。框架也是一样，框架，是为了我们不必总是写相同代码而诞生的。框架，是为了让我们专注于业务逻辑而诞生的。框架，把我们程序设计中不变的部分抽取出来，让我们专注于与业务有关的代码。</p> <p>框架，只是简化了程序员的工作，将很多的类库集成到一起。你会用框架就行，不需要理解框架是怎样做到这一点的。它是怎样做到的。 这些你可以不理。当然你想做一个出色的程序员，去理解是有必要的。</p> <p>我个人觉得开发框架的约定的作用远远大于他的类库的作用，开发的过程有许多的细节和功能取决于开发过程中的约定，比如如何用单独的文件放网站的配置信息，页面模块如何组织，数据库如何组织等等，这些都需要开发者在编写代码的时候考虑和规划的，而且这些约定如果开始考虑不周的，往往会对后期开发造成很大影响。</p> <p>新手开发往往比较随意，开发约定的设计也比较随意，而且经验不深，碰到的问题也不多，觉得框架的这种约定对他们反而是一种限制，所以很多新手都不喜欢用框架！</p> <p>但是实际上大部分框架的约定规则都是经过深思熟虑和久经考验的（比如MVC），一旦理解了这点，并且在开发中顺着这些约定去规划和考虑问题，就会觉得框架好用的不得了，并且上手和实施都相当容易！</p> <p>我一般建议新手学习框架，不要急于去了解框架的库类等东西，而是应该先去看看这个框架的各种约定！了解整个架构的运作，在看库类就会得心应手了！</p> <p>特别是其实大部分框架的核心原理都是基于MVC结构的，你了解了一个框架，其它框架也就得心应手了！</p> <h3 id="_1-3-框架和设计模式"><a href="#_1-3-框架和设计模式" class="header-anchor">#</a> 1.3 框架和设计模式</h3> <p>框架、设计模式这两个概念总容易被混淆，其实它们之间还是有区别的。构件通常是代码重用，而设计模式是设计重用，框架则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用。</p> <p>在软件生产中有三种级别的重用：内部重用，即在同一应用中能公共使用的抽象块;代码重用，即将通用模块组合成库或工具集，以便在多个应用和领域都能使用；应用框架的重用，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性。</p> <p>框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。</p> <p>可以说，框架是软件，而设计模式是软件的知识。</p> <h3 id="_1-4-前后端分离"><a href="#_1-4-前后端分离" class="header-anchor">#</a> 1.4 前后端分离</h3> <p>在前后分离概念出现之前，大部分 web 项目都是后端人员又当爹又当妈的，前后端一起搞，导致质量和效率不是很好。而且对个人的发展也有影响，一个人你什么都会，也意味着你什么都不精，毕竟天才还是少数的。</p> <p>在互联网的洪流下，以前的那种方式越来越跟不上节奏，所以前后端分离应运而生。前后端分离后，前端的任务也变得重要起来，web前端开发慢慢趋于规范。</p> <p>但是在 jQuery 称霸的时代里，并不能满足前端开发人员的需求。也慢慢暴露出了很多不好解决的问题：外部js引用太多，复用性低，开发周期太长，性能低，效率低等等，这些 jQuery 不好解决或者说解决不了的问题，也成为了前端开发的趋势。</p> <h3 id="_1-5-使用前端框架解决了哪些问题？"><a href="#_1-5-使用前端框架解决了哪些问题？" class="header-anchor">#</a> 1.5 使用前端框架解决了哪些问题？</h3> <p>在以前使用jQuery开发时，当项目越来越复杂和庞大的时候，可能会用到各种各样的第三方插件，而且不只是一个页面使用，所以会出现每个页面都要引用一遍相同的js文件，冗余大的问题。</p> <p>这样不仅会使页面代码变得杂乱，而且会影响页面的打开速度，万一以后需要变更一下js文件的路径，还要一个一个去修改，对后期的维护也是很大的负担。</p> <p>使用框架开发时（例如Vue），一般都会搭配构建工具使用（例如webpack），整个项目运行时会有一个入口文件，当你有多个组件都会用到某个文件或插件时，仅仅在这个入口文件引入一次，就可以在你所有组件中使用这个插件的方法，可以说是一劳永逸。就算后期文件位置有所变动，也只是修改入口文件中的引用路径就可以了。</p> <p>组件是前端框架里非常强大的功能之一，它可以扩展你的HTML，封装可以重用的代码块，比如你的轮播图、tab切换、页面头部、页面底部等等。</p> <p>这种独立的组件具有了结构（html），表现（css）和行为（js）完整的功能，很大程度的节省了代码量，提高了代码的复用性。根据不同的需求定制你自己的组件，在需要的页面引用即可。在团队合作开发中，相对独立开发不同的组件，效率上也有很大的提升。</p> <p>jQuery开发时，需要频繁的操作DOM，几乎任何动态效果都需要去选择DOM来进行相应的操作，这使开发变得麻烦起来，很多的时间都用到了操作DOM上，项目的开发周期自然被延长。</p> <p>使用框架开发，框架中封装许多的频繁使用的功能，例如Angular中的指令，指令功能有数据绑定，表单验证，数据格式化等等。这时前端的重点只需要放在数据逻辑部分，而不需要花费很大的精力去操作DOM完成功能，从而加快项目进度。</p> <p>很多DOM操作会引起回流和重绘，对于jQuery来说，大量的操作DOM虽然方便，但是很浪费页面性能。</p> <p>框架和jQuery虽然都会操作DOM，但是框架把大量的DOM进行了处理和优化（例如Vue的虚拟DOM），通过数据驱动，就能渲染出DOM，大大提升了性能。</p> <h3 id="_1-6-如何挑选适合的前端框架？"><a href="#_1-6-如何挑选适合的前端框架？" class="header-anchor">#</a> 1.6 如何挑选适合的前端框架？</h3> <p>最近几年，前端技术迅猛发展，差不多每年都会冒出一款主流的框架。 每次新开业务线或启动新项目时，首先第一件事就是纠结：使用什么框架，重造什么轮子？</p> <p>在十年前，移动端还没有兴起，我们没有什么选择，就是jQuery。有人会说，jQuery只是类库，不是框架；但那时前端业务还没有像今天这么繁重，原本是后端干的事，全部挪到前端来，因为光是jQuery就可以包打天下。jQuery不够用，还有成千上万的jQuery的插件呢。</p> <p>一个页面太多jQuery插件了，请求数太多了，于是我们得打包。打包需要我们对插件有规划。于是这一需求在社区上逐渐形成了某些规则，其中最出名的是AMD规范，体现上RequireJS这个加载库上。</p> <p>RequireJS是前端技术发展上的一个分水岭。JavaScript在ES6之前一直没有自己的加载机制，RequireJS的出现意味着前端可以向更大规模发展。以后我说的技术选型，一个非常重要的甄选点， 即是否存在加载器机制或符合某个模块规范。</p> <p>选择框架要从两面看，一是看该框架的本领，二是看你们团队的能耐。</p> <p>从框架的角度来看， 它的功能丰富不丰富、社区活跃度如何、国内社区活跃度如何（有的在国外流行，但国内只有初创公司或一些大公司的边缘项目在试水）、文档齐全与否、是否及时更新、测试覆盖率如何、上手难易度如何，都是我们考量点。不过能进我们视野内的外国框架，基本是身经百战，在造轮子兴盛的世界闯出来的领头羊。</p> <h3 id="_1-7-什么vue-js？"><a href="#_1-7-什么vue-js？" class="header-anchor">#</a> 1.7 什么Vue.js？</h3> <p>Vue是一套用于构建用户界面的渐进式JavaScript框架，由美籍华人尤雨溪于2015年开源，近两年特别火，国内很多大公司都优先考虑使用vuejs开发web应用甚至是原生或桌面应用。</p> <p>Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组，vue.js 自身不是一个全能框架——它只聚焦于视图层。因此它非常容易学习，非常容易与其它库或已有项目整合。另一方面，在与相关工具和支持库一起使用时，Vue.js 也能完美地驱动复杂的单页应用。</p> <h3 id="_1-8-为何使用vue"><a href="#_1-8-为何使用vue" class="header-anchor">#</a> 1.8 为何使用vue?</h3> <p>很多使用过vue的程序员这样评价它，“vue.js兼具angular.js和react.js的优点，并剔除了它们的缺点”。授予了这么高的评价的vue.js，也是开源世界华人的骄傲，因为它的作者是位中国人–尤雨溪。</p> <p>随着使用的深入我逐渐理解到框架的好处:</p> <ul><li>组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。</li> <li>天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。</li> <li>生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案</li></ul> <h2 id="_02-初始化项目"><a href="#_02-初始化项目" class="header-anchor">#</a> 02 初始化项目</h2> <p>vue/cli 是一个基于 Vue.js 进行快速开发的完整系统，因为vue生态的官方入门教程及文档都写得不错，所以建议大家先去官网通读入门教程 https://cn.vuejs.org/v2/guide/  和脚手架文档  https://cli.vuejs.org/zh/guide/。</p> <h3 id="_2-1-什么是前端脚手架？"><a href="#_2-1-什么是前端脚手架？" class="header-anchor">#</a> 2.1 什么是前端脚手架？</h3> <p>先查查百度百科里对“脚手架”的定义吧：脚手架是为了保证各施工过程顺利进行而搭设的工作平台。</p> <p>然后搜一下“脚手架”，基本上都是以下几类：</p> <ul><li>Vue/React 脚手架</li> <li>使用 Node、yeoman 打造自己的脚手架</li> <li>从零搭建 webpack 脚手架</li></ul> <p>此时还是无法确定什么是“脚手架”，也许我们心目中的脚手架应该是 vue/cli 或者 create-react-app 吧，然后我打开他们的文档，但是他们的介绍上并没有说这是一款脚手架…</p> <p>我们不妨看看类似的一些成熟方案，比如Eclipse。这个大名鼎鼎的IDE软件被很多Java和Android开发者使用。</p> <p>通过Eclipse创建一个新项目时，它提供了丰富的配置项，这些配置项可以归纳简化为以下流程：选择项目类型 -&gt; 选择项目目录 -&gt; 配置项目细节 -&gt; 最终确认 -&gt; 完成。</p> <p>这是脚手架最基本也是必须具备的流程。从这个流程中可以总结出脚手架的本质：方案的封装。</p> <p>随着前端工程化的概念越来越深入人心，脚手架的出现就是为减少重复性工作而引入的命令行工具，摆脱ctrl + c, ctrl + v。</p> <p>现在新建一个前端项目，已经不是在html头部引入css，尾部引入js那么简单的事了，css都是采用Sass或则Less编写，在js中引入，然后动态构建注入到html中。</p> <p>除了学习基本的js，css语法和热门框架，还需要学习构建工具webpack，babel这些怎么配置，怎么起前端服务，怎么热更新；为了在编写过程中让编辑器帮我们查错以及更加规范，我们还需要引入ESlint；甚至，有些项目还需要引入单元测试（Jest）。</p> <p>对于一个入门的人来说，这无疑会让人望而却步。而前端脚手架的出现，就让事情简单化，一键命令，新建一个工程，再执行两个npm命令，跑起一个项目。</p> <p>在入门时，无需关注配置什么的，只需要开心的写代码；另外，对于很多系统，他们的页面相似度非常高，所以就可以基于一套模板来搭建，虽然是不同的人开发，但用脚手架来搭建，相同的项目结构与代码书写规范，是很利于项目的后期维护的；以上就是为什么脚手架存在的意义， 让项目从&quot;搭建-开发-部署&quot;更加快速以及规范。</p> <p>现在流行的前端脚手架都是基于NodeJs编写，比如前面提到的vue-CLI和create-react-app，都是热门框架vue和react的项目脚手架，其功能都是生成一个通用的目录结构，并配上构建、编译、检查等工程环境。大致流程如下：</p> <p>解析用户输入的命令；</p> <ul><li>生成一些配置化文件，如package.json， 或webpack.config.js等；</li> <li>根据用户的输入生成对应的模板项目；（高级一点的ctrl + c, ctrl + v）</li> <li>安装该模板所需要的环境。</li></ul> <h3 id="_2-2-使用-vue-cli-初始化项目"><a href="#_2-2-使用-vue-cli-初始化项目" class="header-anchor">#</a> 2.2 使用 vue-cli 初始化项目</h3> <div class="language- extra-class"><pre class="language-text"><code># 全局安装 vue 脚手架工具
npm install -g @vue/cli
# 创建项目
vue create fs02-vue-video
# 启动项目
cd fs02-vue-video 
npm run serve
</code></pre></div><p>使用 @vue/cli3.0 生成的项目结构和具体作用如下：</p> <div class="language- extra-class"><pre class="language-text"><code>node_moules：存放的是npm加载的项目依赖模块 ，以后要添加依赖也是放在这个里面
src：放置组件和入口文件。
assets：主要存放一些静态图片资源的目录。(css 等也可放在这里)
views :放置的为公共组件(主要还是各个主要页面)
components：(自定义功能组件)这里存放的是开发需要的的各种组件，各个组件联系在一起组成一个完整的项目。
router：存放了项目路由文件。
App.vue：是项目主(/根)组件，***也是项目所有组件和路由的出口***，之后它会被渲染到项目根目录的 index.html 中显示出来，我们可以在这里写一些适合全局的css样式。
main.js：入口文件，引入了vue模块和app.vue组件以及路由router，我们需要在全局使用的一些东西也可以定义在这里面。
store.js: 为vuex的文件
.babelrc：ES6语法编译配置。
.editorconfig：代码编写规格。
.eslintignore：项目的根目录中创建文件来告诉ESLint忽略特定的文件和目录，该文件是纯文本文件。
.eslintrc.js：eslint的配置文件，eslint是用来管理和检测js代码风格的工具，可以和编辑器搭配使用，如vscode的eslint插件，当有不符合配置文件内容的代码出现就会报错或者警告。
.gitignore：忽略的文件。
.postcssrc.js：兼容选项（如果已经安装postcss，需要一大堆loader配置，这时项目根目录会生成“.postcssrc.js”文件）。
package.json：项目及工具的依赖配置文件
paxkage-lock.json(这个文件十分重要不可丢失)
README.md：项目说明。
</code></pre></div><h2 id="_03-vue基础用法"><a href="#_03-vue基础用法" class="header-anchor">#</a> 03 vue基础用法</h2> <p>本节我们将基于我们上一节课初始化的项目，结合功能的实现，来讲解一下vue的一些基础知识和用法。</p> <h3 id="_3-1-什么是单文件组件"><a href="#_3-1-什么是单文件组件" class="header-anchor">#</a> 3.1 什么是单文件组件</h3> <p>在很多 Vue 项目中，我们使用 Vue.component 来定义全局组件，紧接着用 new Vue({ el: '#container '}) 在每个页面内指定一个容器元素。</p> <p>这种方式在很多中小规模的项目中运作的很好，在这些项目里 JavaScript 只被用来加强特定的视图。</p> <p>文件扩展名为 .vue 的 single-file components(单文件组件) 为以上所有问题提供了解决方法，并且还可以使用 webpack 或 Browserify 等构建工具。</p> <p>以下是我们使用官方脚手架初始化项目的一个实例：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
    &lt;h1&gt;{{ msg }}&lt;/h1&gt;
    &lt;p&gt;
      For a guide and recipes on how to configure / customize this project,&lt;br&gt;
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'HelloWorld',
  props: {
    msg: String,
  },
};
&lt;/script&gt;

&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;
&lt;style scoped lang=&quot;stylus&quot;&gt;
h3
  margin 40px 0 0
&lt;/style&gt;

</code></pre></div><p>vuejs 自定义了这种.vue文件，可以把html, css, js 写到一个文件中，从而实现了对一个组件的封装， 一个.vue 文件就是一个单独的组件。由于.vue文件是自定义的，浏览器不认识，所以需要对该文件进行解析。 在webpack构建中，需要安装vue-loader 对.vue文件进行解析。</p> <p>可以看到，在 .vue 文件中， template 中都是html 代码，它定义了在页面中显示的内容，由于里面还有变量，也可以说定义了一个模版；script中都是js 代码，它定义这个组件中所需要的数据和及其操作，style 里面是css 样式，定义这个组件的样式，scoped 表明这里写的css 样式只适用于该组件，可以限定样式的作用域。</p> <h3 id="_3-2-export-defalut-后面的对象的理解"><a href="#_3-2-export-defalut-后面的对象的理解" class="header-anchor">#</a> 3.2 export defalut 后面的对象的理解</h3> <p>在.vue文件中，export default 后面的对象就相当于 new Vue() 构造函数中的接受的对象，它们都是定义组件所需要的数据（data）, 以及操作数据的方法等， 更为全面的一个 export default 对象，有methods, data, computed, 这时可以看到, 这个对象和new Vue() 构造函数中接受的对象是一模一样的。</p> <p>但要注意data 的书写方式不同。在 .vue 组件, data 必须是一个函数，它return（返回一个对象），这个返回的对象的数据，供组件实现。</p> <h3 id="_3-3-v-if-和-v-show"><a href="#_3-3-v-if-和-v-show" class="header-anchor">#</a> 3.3 v-if 和 v-show</h3> <p>相同点： 都能够实现指定内容的显示和隐藏操作的效果</p> <p>不同点：</p> <ul><li>手段：v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏；</li> <li>编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li> <li>编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；</li> <li>性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li></ul> <p>使用场景：</p> <ul><li>当一个元素会被频繁的显示和影藏时，使用v-show。</li> <li>当元素在响应式网页的操作过程中，根据不同用户的需求，可能永远不会被显示或被隐藏，则选择使用v-if。</li></ul> <p>总结:
v-if判断是否加载，可以减轻服务器的压力，在需要时加载,但有更高的切换开销;v-show调整DOM元素的CSS的dispaly属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p> <h3 id="_3-4-用-v-for-把一个数组对应为一组元素"><a href="#_3-4-用-v-for-把一个数组对应为一组元素" class="header-anchor">#</a> 3.4 用 v-for 把一个数组对应为一组元素</h3> <p>我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;ul id=&quot;example-1&quot;&gt;
  &lt;li v-for=&quot;item in items&quot;&gt;
    {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre></div><p>然后在data对象中添加：</p> <div class="language- extra-class"><pre class="language-text"><code>data: {
  items: [
    { message: 'Foo' },
    { message: 'Bar' }
  ]
}
</code></pre></div><p>在 v-for 块中，我们可以访问所有父作用域的属性。v-for 还支持一个可选的第二个参数，即当前项的索引。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;ul id=&quot;example-2&quot;&gt;
  &lt;li v-for=&quot;(item, index) in items&quot;&gt;
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre></div><p>你也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;
</code></pre></div><p>也可以用 v-for 来遍历一个对象的属性, v-for 还可以接受整数。还有，在自定义组件上，你可以像在任何普通元素上一样使用 v-for 。</p> <h3 id="_3-5-v-for-与-v-if-一同使用"><a href="#_3-5-v-for-与-v-if-一同使用" class="header-anchor">#</a> 3.5 v-for 与 v-if 一同使用</h3> <p>官网不推荐在同一元素上使用 v-if 和 v-for。</p> <p>当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你只想为部分项渲染节点时，这种优先级的机制会十分有用。</p> <h3 id="_3-6-事件处理"><a href="#_3-6-事件处理" class="header-anchor">#</a> 3.6 事件处理</h3> <p>可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;example-1&quot;&gt;
  &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;
  &lt;p&gt;The button above has been clicked {{ counter }} times.&lt;/p&gt;
&lt;/div&gt;

data: {
  counter: 0
}
</code></pre></div><p>然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称，不过这个方法需要定义在 methods 模块中。</p> <p>缩写：v-on: 可以用 @ 来替代，效果一样，比如v-on:click 可以改成 @click。</p> <h3 id="_3-7-表单输入绑定"><a href="#_3-7-表单输入绑定" class="header-anchor">#</a> 3.7 表单输入绑定</h3> <p>可以用 v-model 指令在表单 <code>&lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p> <p>v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。</p> <p>v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p> <ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li> <li>checkbox 和 radio 使用 checked 属性和 change 事件；</li> <li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;
&lt;p&gt;Message is: {{ message }}&lt;/p&gt;
</code></pre></div><p>对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)。</p> <p>但是有时我们可能想把值绑定到 Vue 实例的一个动态属性上，这时可以用 v-bind 实现，并且这个属性的值可以不是字符串。</p> <h3 id="_3-8-生命周期函数"><a href="#_3-8-生命周期函数" class="header-anchor">#</a> 3.8 生命周期函数</h3> <p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p> <p>比如 created 钩子可以用来在一个实例被创建之后执行代码：</p> <div class="language- extra-class"><pre class="language-text"><code>data: {
  a: 1
},
created: function () {
  // `this` 指向 vm 实例
  console.log('a is: ' + this.a)
}
</code></pre></div><p>也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 mounted、updated 和 destroyed。生命周期钩子的 this 上下文指向调用它的 Vue 实例。</p> <ul><li>beforeCreate：实例组件刚创建，元素DOM和数据都还没有初始化，暂时不知道能在这个周期里面进行生命操作。</li> <li>created：数据data已经初始化完成，方法也已经可以调用，但是DOM为渲染。在这个周期里面如果进行请求是可以改变数据并渲染，由于DOM未挂载，请求过多或者占用时间过长会导致页面线上空白。</li> <li>beforeMount：DOM未完成挂载，数据也初始化完成，但是数据的双向绑定还是显示{{}}，这是因为Vue采用了Virtual DOM（虚拟Dom）技术。先占住了一个坑。</li> <li>mounted：数据和DOM都完成挂载，在上一个周期占位的数据把值给渲染进去。一般请求会放在这个地方，因为这边请求改变数据之后刚好能渲染。</li> <li>beforeUpdate：只要是页面数据改变了都会触发，数据更新之前，页面数据还是原来的数据，当你请求赋值一个数据的时候会执行这个周期，如果没有数据改变不执行。</li> <li>updated：只要是页面数据改变了都会触发，数据更新完毕，页面的数据是更新完成的。beforeUpdate和updated要谨慎使用，因为页面更新数据的时候都会触发，在这里操作数据很影响性能和容易死循环。</li> <li>beforeDestroy：这个周期是在组件销毁之前执行，在我项目开发中，觉得这个其实有点类似路由钩子beforeRouterLeave,都是在路由离开的时候执行，只不过beforeDestroy无法阻止路由跳转，但是可以做一些路由离开的时候操作，因为这个周期里面还可以使用data和method。比如一个倒计时组件，如果在路由跳转的时候没有清除，这个定时器还是在的，这时候就可以在这个里面清除计时器。</li> <li>Destroyed：说实在的，我还真的不知道这个周期跟beforeDestroy有什么区别，我在这个周期里面调用data的数据和methods的方法都能调用，所以我会觉得跟beforeDestroy是一样的。</li></ul> <h2 id="_04-官方的扩展库"><a href="#_04-官方的扩展库" class="header-anchor">#</a> 04 官方的扩展库</h2> <p>使用Vue开发应用，如果需要做比较复杂的单页应用，就需要引入一些拓展库，如处理路由跳转的vue-router，处理数据的vuex，处理请求的axios等，本节重点讲解vue-router 和vuex 这两个官方库。</p> <h3 id="_4-1-vue-router"><a href="#_4-1-vue-router" class="header-anchor">#</a> 4.1 vue-router</h3> <p>详情请看官网 https://router.vuejs.org/zh/
在现代前端开发中，路由是非常重要的一环。但路由到底是什么呢？</p> <p>有些说：路由就是指随着浏览器地址栏的变化，展示给用户的页面也不相同，这是从路由的用途上来解释路由是什么的。</p> <p>还有一种说法是：路由就是URL到函数的映射。这是从路由的实现原理上来解释路由是什么的。</p> <p>路由这个概念最先是后端出现的，在以前用模板引擎开发页面时，经常会看到这样：</p> <div class="language- extra-class"><pre class="language-text"><code>http://xxx.edu.cn/bbs/forum.php
</code></pre></div><p>有时还会有带<code>.asp</code>或<code>.html</code>的路径，这就是所谓的SSR(Server Side Render)，通过服务端渲染，直接返回页面，其响应过程是这样的 ：</p> <ul><li>浏览器发出请求</li> <li>服务器监听到 80 端口（或 443）有请求过来，并解析 url 路径</li> <li>根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等）</li> <li>浏览器根据数据包的<code>Content-Type</code>来决定如何解析数据</li></ul> <p>简单来说，路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不 同的资源，请求不同的页面是路由的其中一种功能。</p> <p>前端路由的诞生的缘由前端路由的出现要从 ajax 开始，Ajax，全称 Asynchronous JavaScript And XML，是浏览器用来实现异步加载的一种技术方案。</p> <p>在 90 年代初，大多数的网页都是通过直接返回 HTML 的，用户 的每次更新操作都需要重新刷新页面。极其影响交互体验，随着网络的发展，迫切需要一种方案来改善这种情况。</p> <p>1996，微软首先提出 iframe 标 签，iframe 带来了异步加载和请求元素的概念，随后在 1998 年，微软的 Outloook Web App 团队提出 Ajax 的基本概念（XMLHttpRequest 的前身），并在 IE5 通过 ActiveX 来实现了这项技术。</p> <p>在微软实现这个概念后，其他浏览器比如 Mozilia，Safari，Opera 相继以 XMLHttpRequest 来实现 Ajax。</p> <p>有了 Ajax 后，用户交互就不用每次都刷新页面， 体验带来了极大的提升。但真正让这项技术发扬光大的，还是后来的Google Map，它的出现向人们展现了 Ajax 的真正魅力，释放了众多开发 人员的想象力，让其不仅仅局限于简单的数据和页面交互，为后来异步交 互体验方式的繁荣发展带来了根基。而异步交互体验的更高级版本就是SPA——单页应用。</p> <p>单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。单页应用的概念是伴随着 MVVM 出现的。</p> <p>最早由微软提出，然后他们在浏览器端用 <code>Knockoutjs</code> 实现。但这项技术的强大之处并未当时的开发者体会到，可能是因为 <code>Knockoutjs</code> 实现过于复杂，导致没有大面积的扩散。</p> <p>同样，这次接力的选手依然是 Google。Google 通过 Angularjs 将 MVVM 及单页应用发扬光大，让前端开发者能够开发出更加大型的应用，职能变得更大了，随后前端圈开始得到了爆发式的发展，陆续出现了很多优秀的框架。</p> <p>前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 不同返回不同的页面来实现。</p> <p>目前前端路由方案主要有以下几种 ：</p> <ul><li>hash：可能是大多数人了解的模式，主要是基于锚点的原理实现。简单易 用</li> <li>history：即使用 html5 标准中的 history api 通过监听 popstate 事件来对 dom 进行操作。每次路由变化都会引起重定向</li> <li>memory：这种实现是在内存中维护一个堆栈用于管理访问历史的方式比较复杂，在早期移动端使用比较多。实现麻烦，问题也较多，现在很少有使用，RN 在使用这种路由模式。</li> <li>static：主要用于 ssr，需要后端去管理路由。</li></ul> <p>前端路由各种实现方案的对比：</p> <ul><li>hash 路由优缺点：
<ul><li>优点： 实现简单，兼容性好（兼容到 ie8） 绝大多数前端框架均提供了给予 hash 的路由实现 不需要服务器端进行任何设置和开发 除了资源加载和 ajax 请求以外，不会发起其他请求。</li> <li>缺点： 对于部分需要重定向的操作，后端无法获取 hash 部分内容，导致后台无 法取得 url 中的数据，典型的例子就是微信公众号的 oauth 验证 服务器端无法准确跟踪前端路由信息 对于需要锚点功能的需求会与目前路由机制冲突</li></ul></li> <li>History 模式路由优缺点：
<ul><li>优点 ：对于重定向过程中不会丢失 url 中的参数。后端可以拿到这部分数据。绝大多数前段框架均提供了 history 模式的路由实现。后端可以准确跟踪路由信息 可以使用 history.state 来获取当前 url 对应的状态信息</li> <li>缺点：兼容性不如 hash 路由(只兼容到 IE10) 需要后端支持，每次返回 html 文档</li></ul></li> <li>memory 路由优缺点：
<ul><li>优点：不存在兼容性问题，路由保存在内存中 不需要服务器端提供支持</li> <li>缺点：目前很少有前端路由模块提供对 memory 路由的实现(react-router 提供了 memory 实现) ，自己实现难度较大，且工作量也很大，对于前进后退操作的路由管理非常麻烦，尤其是android设备的backbutton</li></ul></li></ul> <p>hash 模式适用场景：兼容 IE8 没有重定向传参需求(第三方认证 oauth) ，没有锚点跳跃需求，后端不需要跟踪前端路由信息。hybrid app 需要将前端资源打包在应用内，因为 html 的域在 file://下，所以不能发生重定向。</p> <p>history 模式适用场景：页面内锚点需求，需要重定向传参，同构直出，后端跟踪路由信息，附加路由信息(history.state)获取路由状态。</p> <p>从 vue-router 来看前端路由实现原理：前端路由的实现其实很简单。 本质上就是检测 url 的变化，截获 url 地址，然后解析来匹配路由规则；检测到 hash 的变化后，就可以通过替换 DOM 的方式来实现页面的更换。</p> <p>14 年后，因为 HTML5 标准发布。多了两个 API，pushState 和 replaceState， 通过这两 个 API 可以改变 url 地址且不会发送请求。同时还有 onpopstate 事件。通过这些就能用另一种方式来实现前端路由了，但原理 都是跟 hash 实现相同的。</p> <p>用了 HTML5 的实现，单页路由的 url 就不会 多出一个#，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类 的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。</p> <h3 id="_4-2-vuex"><a href="#_4-2-vuex" class="header-anchor">#</a> 4.2 vuex</h3> <p>使用vuex 请阅读 https://vuex.vuejs.org/zh/ 。</p> <p>不管是Vue，还是 React，都需要管理状态（state），比如组件之间都有共享状态的需要。什么是共享状态？比如一个组件需要使用另一个组件的状态，或者一个组件需要改变另一个组件的状态，都是共享状态。</p> <p>父子组件之间，兄弟组件之间共享状态，往往需要写很多没有必要的代码，比如把状态提升到父组件里，或者给兄弟组件写一个父组件，听听就觉得挺啰嗦。</p> <p>如果不对状态进行有效的管理，状态在什么时候，由于什么原因，如何变化就会不受控制，就很难跟踪和测试了。如果没有经历过这方面的困扰，可以简单理解为会搞得很乱就对了。</p> <p>在软件开发里，有些通用的思想，比如隔离变化，约定优于配置等，隔离变化就是说做好抽象，把一些容易变化的地方找到共性，隔离出来，不要去影响其他的代码。</p> <p>约定优于配置就是很多东西我们不一定要写一大堆的配置，比如我们几个人约定，view 文件夹里只能放视图，不能放过滤器，过滤器必须放到 filter 文件夹里，那这就是一种约定，约定好之后，我们就不用写一大堆配置文件了，我们要找所有的视图，直接从 view 文件夹里找就行。</p> <p>根据这些思想，对于状态管理的解决思路就是：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测。根据这个思路，产生了很多的模式和库。</p> <p>vuex 其实是一个针对 Vue 特化的 Flux，主要是为了配合 Vue 本身的响应式机制。当然吸取了一些 Redux 的特点，比如单状态树(用一个对象就包含了所有的应用层级状态，至此它便作为唯一数据源的存在，这也意味着没一个应用仅仅包含一个store实例，单一的状态树能够让我们直接的定位任一特定状态片段)和便于测试和热重载的 API。</p> <p>但是也选择性的放弃了一些在 Vue 的场景下并不契合的特性，比如强制的 immutability（在保证了每一次状态变化都能追踪的情况下强制的 immutability 带来的收益就很有限了）、为了同构而设计得较为繁琐的 API、必须依赖第三方库才能相对高效率地获得状态树的局部状态等等（相比之下 Vuex 直接用 Vue 本身的计算属性就可以）。</p> <p>所以 Vue + Vuex 会更简洁，也不需要考虑性能问题，代价就是 Vuex 只能和 Vue 配合。Vue + Redux 也不是不可以，但是 Redux 作为一个泛用的实现和 Vue 的契合度肯定不如 Vuex。</p> <h2 id="_05-使用axios请求数据"><a href="#_05-使用axios请求数据" class="header-anchor">#</a> 05 使用axios请求数据</h2> <p>Vue.js 2.0 版本推荐使用 axios 来完成 ajax 请求，Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p> <p>Github开源地址： https://github.com/axios/axios。</p> <p>源码分析：https://juejin.im/post/5b0ba2d56fb9a00a1357a334 和 https://blog.csdn.net/qq_36407875/article/details/84642060。</p> <h3 id="_5-1-axios-有哪些特性？"><a href="#_5-1-axios-有哪些特性？" class="header-anchor">#</a> 5.1 Axios 有哪些特性？</h3> <ul><li>支持 Promise API</li> <li>拦截请求和相应</li> <li>转换请求数据和相应数据</li> <li>取消请求</li> <li>自动转换 JSON 数据</li> <li>客户端支持防御 XSRF</li></ul> <h3 id="_5-2-使用axios"><a href="#_5-2-使用axios" class="header-anchor">#</a> 5.2 使用axios</h3> <p>一般我们都同意配置一些技术配置或封装一些方法：</p> <div class="language- extra-class"><pre class="language-text"><code>import axios from 'axios';
import router from '../router';

const baseURL = '/';

const api = axios.create({
  baseURL,
});
api.defaults.headers.post['Content-Type'] = 'application/json;charset=UTF-8';
api.defaults.timeout = 50000;

api.interceptors.request.use(
  (config) =&gt; {
    const token = JSON.parse(localStorage.getItem('token'));
    if (token) {
      config.headers.Authorization = token;
    }
    return config;
  },
  (err) =&gt; Promise.reject(err),
);

api.interceptors.response.use(
  (res) =&gt; {
    if (res.data.code === 401) {
      router.replace({ name: 'login' });
    } else {
      return res;
    }
  },
  (error) =&gt; {
    router.replace({ name: 'login' });
    return Promise.reject(error.response);
  },
);

const get = (url, params) =&gt; api.get(url, { params });
const post = (url, data) =&gt; api.post(url, data);
const put = (url, data) =&gt; api.put(url, data);

export { get, post, put };

</code></pre></div><p>然后使用时就可以：</p> <div class="language- extra-class"><pre class="language-text"><code>import { get, post } from './cfg';

export default {
  getOptions() {
    return get('/api/base/options');
  },
  login(params) {
    return post('api/user/login', params);
  },
  sendSms(params) {
    return post('api/base/sendsms', params);
  },
};

</code></pre></div><h3 id="_5-3-添加vue-config-js"><a href="#_5-3-添加vue-config-js" class="header-anchor">#</a> 5.3 添加vue.config.js</h3> <p>vue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。</p> <p>我们也可以使用 package.json 中的 vue 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写。</p> <p>vue-cli3 脚手架搭建完成后，项目目录中没有 vue.config.js 文件，需要手动创建，因为webpack的配置均被隐藏了，当你需要覆盖原有的配置时，则需要在项目的根目录下，新建vue.config.js文件，来配置新的配置。</p> <div class="language- extra-class"><pre class="language-text"><code>const proxyUrl = 'https://t.yibiankeji.com';
// const proxyUrl = 'http://localhost:3600';

module.exports = {
  devServer: {
    open: true,
    host: '0.0.0.0',
    port: 3603,
    https: false,
    hotOnly: false,
    proxy: {
      '/api': {
        target: proxyUrl,
        ws: true,
        changeOrigin: true,
      },
    },
  },
};
</code></pre></div><p>此时，我们通过axios 发起的请求，就能转发到我们部署在阿里云服务器上的接口服务了。</p> <h2 id="_06-参与开发视频网站"><a href="#_06-参与开发视频网站" class="header-anchor">#</a> 06 参与开发视频网站</h2> <p>视频学习网站的最终效果为访问：<a href="http://t.yibiankeji.com/" target="_blank" rel="noopener noreferrer">http://t.yibiankeji.com/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h2 id="_07-参与开发后台系统"><a href="#_07-参与开发后台系统" class="header-anchor">#</a> 07 参与开发后台系统</h2> <p>后台管理系统的最终效果为访问：<a href="http://t-admin.yibiankeji.com/" target="_blank" rel="noopener noreferrer">http://t-admin.yibiankeji.com/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h2 id="_08-模拟面试"><a href="#_08-模拟面试" class="header-anchor">#</a> 08 模拟面试</h2> <p>本节我们将通过模拟面试的方式，带大家回顾一下这个系列的知识点。</p> <h3 id="_8-1-如何让css只在当前组件中起作用"><a href="#_8-1-如何让css只在当前组件中起作用" class="header-anchor">#</a> 8.1 如何让CSS只在当前组件中起作用?</h3> <p>在当前组件的style中加入scoped：<code>&lt;style scoped&gt;</code>，scoped 有限制在某范围的含义，如果不设置，容易引起样式错乱！</p> <h3 id="_8-2-vue项目如何适配移动端？"><a href="#_8-2-vue项目如何适配移动端？" class="header-anchor">#</a> 8.2 vue项目如何适配移动端？</h3> <p>一般会引入淘宝移动端布局库amfe-flexible，不过由于viewport单位得到众多浏览器的兼容，该库维护团队建议使用viewport来替代此方案。但使用viewport也需要解决兼容问题。</p> <h3 id="_8-3-v-if和v-show的异同"><a href="#_8-3-v-if和v-show的异同" class="header-anchor">#</a> 8.3 v-if和v-show的异同?</h3> <ul><li>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</li> <li>v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏</li></ul> <h3 id="_8-4-组件之间的如何传值？"><a href="#_8-4-组件之间的如何传值？" class="header-anchor">#</a> 8.4 组件之间的如何传值？</h3> <ul><li>父组件与子组件传值
<ul><li>父组件通过标签上面定义传值</li> <li>子组件通过props方法接受数据</li></ul></li> <li>子组件向父组件传递数据
<ul><li>子组件通过$emit方法传递参数</li></ul></li></ul> <h3 id="_8-5-页面如何跳转？"><a href="#_8-5-页面如何跳转？" class="header-anchor">#</a> 8.5 页面如何跳转？</h3> <ul><li>声明式（标签跳转）</li> <li>编程式（借助vue-router）</li></ul> <h3 id="_8-6-vue-cli中怎样使用自定义的组件？"><a href="#_8-6-vue-cli中怎样使用自定义的组件？" class="header-anchor">#</a> 8.6 vue-cli中怎样使用自定义的组件？</h3> <ul><li>在components目录新建你的组件文件；</li> <li>在需要用的页面（组件）中导入；</li> <li>注入到vue的组件的components属性上面；</li> <li>在template视图view中使用。</li></ul> <h3 id="_8-7-请谈谈vue生命周期钩子函数"><a href="#_8-7-请谈谈vue生命周期钩子函数" class="header-anchor">#</a> 8.7 请谈谈Vue生命周期钩子函数?</h3> <ul><li>vue 实例从创建到销毁的过程，就是生命周期；</li> <li>创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有；</li> <li>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染；</li> <li>更新前/后：当data变化时，会触发beforeUpdate和updated方法；</li> <li>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在；</li> <li>vue生命周期中的事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</li></ul> <h3 id="_8-8-谈谈-keep-alive"><a href="#_8-8-谈谈-keep-alive" class="header-anchor">#</a> 8.8 谈谈 keep-alive?</h3> <p><code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例, 主要用于保留组件状态或避免重新渲染，在activated生命周期函数可以做相应处理。</p> <h3 id="_8-9-在vue中如何使用插件？"><a href="#_8-9-在vue中如何使用插件？" class="header-anchor">#</a> 8.9 在vue中如何使用插件？</h3> <ul><li>采用ES6的import ... from ...语法或CommonJS的require()方法引入插件；</li> <li>使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true })；</li></ul> <h3 id="_8-10-为什么使用key？"><a href="#_8-10-为什么使用key？" class="header-anchor">#</a> 8.10 为什么使用key？</h3> <p>当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。</p> <h3 id="_8-11-为什么避免-v-if-和-v-for-用在一起？"><a href="#_8-11-为什么避免-v-if-和-v-for-用在一起？" class="header-anchor">#</a> 8.11 为什么避免 v-if 和 v-for 用在一起？</h3> <p>当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。</p> <h3 id="_8-12-怎么使用vuex？"><a href="#_8-12-怎么使用vuex？" class="header-anchor">#</a> 8.12 怎么使用vuex？</h3> <ul><li>在src下新建一个目录vuex；</li> <li>如果不用模块功能的话，在vuex下创建一个index.js文件；</li> <li>然后引入vuex, 创建相关的state,actions,getters, mutations并导出；</li> <li>在main.js中引入vuex并注入vue实例。</li></ul> <h3 id="_8-13-vuex的state特性"><a href="#_8-13-vuex的state特性" class="header-anchor">#</a> 8.13 vuex的State特性</h3> <ul><li>vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data;</li> <li>state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新;</li> <li>它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中;</li></ul> <h3 id="_8-14-vuex的getter特性"><a href="#_8-14-vuex的getter特性" class="header-anchor">#</a> 8.14 vuex的Getter特性</h3> <ul><li>getters 可以对State进行计算操作，它就是Store的计算属性</li> <li>虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用</li> <li>如果一个状态只在一个组件内使用，是可以不用getters</li></ul> <h3 id="_8-15-不用vuex会带来什么问题？"><a href="#_8-15-不用vuex会带来什么问题？" class="header-anchor">#</a> 8.15 不用vuex会带来什么问题？</h3> <ul><li>可维护性会下降，想修改数据要维护三个地方；</li> <li>可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；</li> <li>增加耦合，大量的上传派发，会让耦合性大大增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背;</li></ul> <h3 id="_8-16-怎么定义vue-router的动态路由以及如何获取传过来的动态参数？"><a href="#_8-16-怎么定义vue-router的动态路由以及如何获取传过来的动态参数？" class="header-anchor">#</a> 8.16 怎么定义vue-router的动态路由以及如何获取传过来的动态参数？</h3> <ul><li>在router目录下的index.js文件中，对path属性加上/:id。</li> <li>使用router对象的params.id。</li></ul> <h3 id="_8-17-vue-loader是什么？使用它的用途有哪些？"><a href="#_8-17-vue-loader是什么？使用它的用途有哪些？" class="header-anchor">#</a> 8.17 vue-loader是什么？使用它的用途有哪些？</h3> <ul><li>根据官网的定义，vue-loader 是 webpack 的一个 loader，用于处理 .vue 文件。</li> <li>使用vue-cli脚手架，作者已经配置好了基本的配置，开箱及用，你需要做的就是npm install 安装下依赖，然后就可以开发业务代码了。</li></ul> <h3 id="_8-18-请说出vue-cli项目中src目录每个文件夹和文件的用法？"><a href="#_8-18-请说出vue-cli项目中src目录每个文件夹和文件的用法？" class="header-anchor">#</a> 8.18 请说出vue.cli项目中src目录每个文件夹和文件的用法？</h3> <ul><li>assets文件夹是放静态资源；</li> <li>components是放组件；</li> <li>router是定义路由相关的配置;</li> <li>view视图；app.vue是一个应用主组件；</li> <li>main.js是入口文件</li></ul> <h3 id="_8-19-vue数据双向绑定的实现原理"><a href="#_8-19-vue数据双向绑定的实现原理" class="header-anchor">#</a> 8.19 vue数据双向绑定的实现原理</h3> <ul><li>双向绑定是对表单来说的，表单的双向绑定，说到底不过是 value 的单向绑定 + onChange 事件侦听的一个语法糖。</li> <li>利用数据劫持结合发布订阅模式实现的数据双向绑定：
<ul><li>observer用来对初始数据通过Object.defineProperty添加setter和getter，当取数据（即调用get）的时候添加订阅对象（watcher）到数组里， 当给数据赋值（即调用set）的时候就能知道数据的变化，此时调用发布订阅中心的notify，从而遍历当前这个数据的订阅数组，执行里面所有的watcher，通知变化update。</li> <li>compiler是用来把data编译到dom中；</li> <li>watcher是oberver和compiler之间通信的桥梁；</li></ul></li></ul> <h3 id="_8-20-vue-为何用-proxy代替-defineproperty"><a href="#_8-20-vue-为何用-proxy代替-defineproperty" class="header-anchor">#</a> 8.20 vue 为何用 proxy代替 defineProperty</h3> <p>Object.defineProperty是ES5中的方法，它可以直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p> <p>vue2利用Object.defineProperty来劫持data数据的getter和setter操作，动态更新绑定的template模块。</p> <p>然而Object.defineProperty有先天缺陷——无法监听数组变化和只能劫持对象的属性，所以对于数组的监听需要hack它的8种方法，而当属性值也是对象则需要深度遍历，对性能损耗很大。</p> <p>而proxy一是可以直接监听数组的变化；二是可以直接监听对象而非属性，同时，Proxy作为新标准将受到浏览器厂商重点持续的性能优化，唯一的劣势就是兼容性问题,而且无法用polyfill实现。</p> <h3 id="_8-21-vue-最新为何使用function-base-api-而不是class-api"><a href="#_8-21-vue-最新为何使用function-base-api-而不是class-api" class="header-anchor">#</a> 8.21 vue 最新为何使用function base api 而不是class api?</h3> <ul><li>更灵活的逻辑复用能力；</li> <li>更好的TS类型推导；</li> <li>更好的性能；</li> <li>tree-shaking 更好</li> <li>代码更容易被压缩</li></ul> <h3 id="_8-22-vue-vs-react"><a href="#_8-22-vue-vs-react" class="header-anchor">#</a> 8.22 vue vs react</h3> <p>设计不同思路： React 设计是改变开发者，提供强大而复杂的机制，开发者按照我的来；Vue 是适应开发者，让开发者怎么爽怎么来。</p> <p>Vue 进行数据拦截/代理，它对侦测数据的变化更敏感、更精确; React 推崇函数式，它直接进行局部重新刷新（或者重新渲染），这样更粗暴简单，但React 并不知道什么时候“应该去刷新”，触发局部重新变化是由开发者手动调用 setState 完成。</p> <p>在一定程度上，React + Mobx 也可以被认为是更繁琐的 Vue。</p> <p>React 事件系统庞大而复杂。其中，它暴漏给开发者的事件不是原生事件，是 React 包装过合成事件，this 默认不指向组件实例。</p> <p>Vue 向上扩展就是 React，Vue 向下兼容后就类似于 jQuery，渐进式有时候比革命性更符合时代的要求。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/fs/1.html" class="prev">
        从零打造个人博客和简历
      </a></span> <span class="next"><a href="/blog/fs/3.html">
        使用uni-app开发移动端应用
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.2c917b5d.js" defer></script><script src="/blog/assets/js/2.fd5fecfd.js" defer></script><script src="/blog/assets/js/29.847049dd.js" defer></script>
  </body>
</html>
