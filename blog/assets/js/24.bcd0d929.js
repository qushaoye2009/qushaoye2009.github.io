(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{270:function(n,e,t){"use strict";t.r(e);var a=t(28),r=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"常见算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见算法"}},[n._v("#")]),n._v(" 常见算法")]),n._v(" "),t("h2",{attrs:{id:"基础算法题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础算法题"}},[n._v("#")]),n._v(" 基础算法题")]),n._v(" "),t("h3",{attrs:{id:"_1-不需要借助第三个临时变量，实现两个变量的交换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-不需要借助第三个临时变量，实现两个变量的交换"}},[n._v("#")]),n._v(" 1 不需要借助第三个临时变量，实现两个变量的交换")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function swap（a,b）{\n  b = b - a;\n  a = a + b;\n  b = a - b;\n  return [a,b];\n}\n")])])]),t("p",[n._v("或使用位运算实现")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function swap（a,b）{\n  a = a^b\n  b = a^b\n  a = a^b\n  return [a,b];\n}\n")])])]),t("h3",{attrs:{id:"_2-确保字符串的每个单词首字母都大写，其余部分小写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-确保字符串的每个单词首字母都大写，其余部分小写"}},[n._v("#")]),n._v(" 2 确保字符串的每个单词首字母都大写，其余部分小写")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function titleCase(str) {\n  var lstr = str.toLowerCase().split(' ');\n  for(var i = 0 ; i < lstr.length; i++) {\n    lstr[i] = lstr[i][0].toUpperCase() + lstr[i].substring(1, lstr[i].length);\n  }\n  var res = lstr.join(' ');\n  return res;\n}\ntitleCase(\"good night\"); // Good Night\n")])])]),t("h3",{attrs:{id:"_3-找出正整数-数组的最大差值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-找出正整数-数组的最大差值"}},[n._v("#")]),n._v(" 3 找出正整数 数组的最大差值")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function getMaxPro(arr){\n  var min = arr[0];\n  var max = 0;\n  for (var i=0;i<arr.length;i++){\n    var current = arr[i];\n    min = Math.min(min, current);\n    var res = currenr - min;\n    max = Math.max(max, res);\n  }\n  return max;  \n}\n")])])]),t("h3",{attrs:{id:"_4-清除字符串前后的空格（兼容所有浏览器）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-清除字符串前后的空格（兼容所有浏览器）"}},[n._v("#")]),n._v(" 4 清除字符串前后的空格（兼容所有浏览器）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function trim(str) {\n  if (str & typeof str === \"string\") {\n    return str.replace(/(^s*)|(s*)$/g, ''); //去除前后空白符\n  }\n}\n")])])]),t("h3",{attrs:{id:"_5-去掉一组整型数组中重复的值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-去掉一组整型数组中重复的值"}},[n._v("#")]),n._v(" 5 去掉一组整型数组中重复的值")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let unique =  function(arr){\n  let hash={};\n  let data=[];\n  for (let i=0;i < arr.length; i++){\n    if (!hash[arr[i]])  {\n      hash[arr[i]] = true;\n      data.push(arr[i]);\n    }      \n  }\n  return data\n}\n")])])]),t("h3",{attrs:{id:"_6-翻转字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-翻转字符串"}},[n._v("#")]),n._v(" 6 翻转字符串")]),n._v(" "),t("ul",[t("li",[n._v("split（）字符串转成数组；")]),n._v(" "),t("li",[n._v("reverse()翻转数组；")]),n._v(" "),t("li",[n._v("join()数组转化成字符串。")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function reverseString(str){    \n  return str.split('').reverse().join('');\t\n}\n")])])]),t("h3",{attrs:{id:"_7-找到提供的句子中最长的单词，并计算它的长度。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-找到提供的句子中最长的单词，并计算它的长度。"}},[n._v("#")]),n._v(" 7 找到提供的句子中最长的单词，并计算它的长度。")]),n._v(" "),t("ul",[t("li",[n._v("转化成数组；")]),n._v(" "),t("li",[n._v("根据元素长度排序；")]),n._v(" "),t("li",[n._v("输出最长元素并返回长度。")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function findLongestString(str){\n  var arr = str.split(' ');\t\n  var arrSort = arr.sort(function (a,b) {\t   \n    return b.length - a.length;\n  });\n  return [arrSort[0], arrSort[0].length];\n}\n")])])]),t("h3",{attrs:{id:"_8-截断一个字符串，如果字符串的长度比指定的参数num长，则把多余的部分用-来表示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-截断一个字符串，如果字符串的长度比指定的参数num长，则把多余的部分用-来表示"}},[n._v("#")]),n._v(" 8 截断一个字符串，如果字符串的长度比指定的参数num长，则把多余的部分用...来表示")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function truncate(str, num){\n  var trStr = str.slice(0, num);\n  if (trStr.length > num) {\t\t\t\t\t\n    return trStr.concat('...');\n  } else {\n    return str;\n  }\n}\n")])])]),t("h3",{attrs:{id:"_9-判断一个字符串中出现次数最多的字符，统计这个次数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-判断一个字符串中出现次数最多的字符，统计这个次数"}},[n._v("#")]),n._v(" 9 判断一个字符串中出现次数最多的字符，统计这个次数")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("funcion findMaxStrCount(str) {\n  var countObj = {};\n  var max = '';\n  for(var i = 0; i < str.length; i++) {\n    var cur = str[i];\n    if(!countObj[cur]) {\n      countObj[cur] = 0;\n    } \n    countObj[cur]++;\n    if(max === '' || countObj[cur] > countObj[max]) { max = cur; }\n  }\n  return [max, countObj[max]];\n}\n\n")])])]),t("h3",{attrs:{id:"_10-快速排序（quick-sort）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-快速排序（quick-sort）"}},[n._v("#")]),n._v(" 10 快速排序（Quick Sort）")]),n._v(" "),t("p",[n._v("快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var quickSort = function(arr) {\n　if (arr.length <= 1) { return arr; }\n　var pivotIndex = Math.floor(arr.length / 2);\n　var pivot = arr.splice(pivotIndex, 1)[0];\n　var left = [];\n　var right = [];\n　for (var i = 0; i < arr.length; i++){\n　　if (arr[i] < pivot) {\n　　　left.push(arr[i]);\n　　} else {\n　　　right.push(arr[i]);\n　　}\n　}\n　return quickSort(left).concat([pivot], quickSort(right));\n};\n")])])]),t("h3",{attrs:{id:"_11-斐波那契数列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-斐波那契数列"}},[n._v("#")]),n._v(" 11 斐波那契数列")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function fib(n){\n  if(typeof n === 'number' && n > 0 && parseInt(n) === n ) {\n    return n < 2 ? 1 : fib(n-1)+fib(n-2);　\n  } else {\n    return '输入不合法，请输入正整数！'；\n  }　　　\n}\n")])])]),t("h3",{attrs:{id:"_12-深拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-深拷贝"}},[n._v("#")]),n._v(" 12 深拷贝")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function deepCopy(obj) {\n  const copyObj = obj instanceof Array ? [] : {};\n  for (const o in obj) {\n    if (obj.hasOwnProperty(o)) {\n      if (typeof obj[o] !== 'object' || obj[o] === null) {\n        copyObj[o] = obj[o];\n      } else {\n        copyObj[o] = deepCopy(obj[o]);\n      }\n    }\n  }\n  return copyObj;\n}\n")])])]),t("h3",{attrs:{id:"_13-防抖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-防抖"}},[n._v("#")]),n._v(" 13 防抖")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const debounce = (fn, time) => {\n  let timer = null;\n  if (timer) clearTimeout(timer);\n  timer = setTimeout(() => {\n    fn();\n  }, time);\n};\n")])])]),t("h3",{attrs:{id:"_14-节流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-节流"}},[n._v("#")]),n._v(" 14 节流")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const throttle = function (fn, time) {\n  let last = 0;\n  const now = new Date().getTime();\n  if (now - last > time) {\n    fn();\n    last = now;\n  }\n};\n")])])]),t("h2",{attrs:{id:"进阶算法题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进阶算法题"}},[n._v("#")]),n._v(" 进阶算法题")]),n._v(" "),t("h3",{attrs:{id:"_15-js实现链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15-js实现链表"}},[n._v("#")]),n._v(" 15 js实现链表")]),n._v(" "),t("p",[n._v("链表其实有许多的种类：单向链表、双向链表、单向循环链表和双向循环链表，接下来，我们基于对象来实现一个单向链表，因为它的使用最为广泛。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v(" //节点\n \nfunction Node(element) {\n    this.element = element;   //当前节点的元素\n    this.next = null;         //下一个节点链接\n    this.previous = null;         //上一个节点链接\n}\n\n//链表类\n\nfunction LList () {\n    this.head = new Node( 'head' );\n    this.find = find;\n    this.findLast = findLast;\n    this.insert = insert;\n    this.remove = remove;\n    this.display = display;\n    this.dispReverse = dispReverse;\n}\n\n//查找元素\n\nfunction find ( item ) {\n    var currNode = this.head;\n    while ( currNode.element != item ){\n        currNode = currNode.next;\n    }\n    return currNode;\n}\n\n//查找链表中的最后一个元素\n\nfunction findLast () {\n    var currNode = this.head;\n    while ( !( currNode.next == null )){\n        currNode = currNode.next;\n    }\n    return currNode;\n}\n\n\n//插入节点\n\nfunction insert ( newElement , item ) {\n    var newNode = new Node( newElement );\n    var currNode = this.find( item );\n    newNode.next = currNode.next;\n    newNode.previous = currNode;\n    currNode.next = newNode;\n}\n\n//显示链表元素\n\nfunction display () {\n    var currNode = this.head;\n    while ( !(currNode.next == null) ){\n        console.debug( currNode.next.element );\n        currNode = currNode.next;\n    }\n}\n\n//反向显示链表元素\n\nfunction dispReverse () {\n    var currNode = this.findLast();\n    while ( !( currNode.previous == null )){\n        console.log( currNode.element );\n        currNode = currNode.previous;\n    }\n}\n\n//删除节点\n\nfunction remove ( item ) {\n    var currNode = this.find ( item );\n    if( !( currNode.next == null ) ){\n        currNode.previous.next = currNode.next;\n        currNode.next.previous = currNode.previous;\n        currNode.next = null;\n        currNode.previous = null;\n    }\n}\n\nvar fruits = new LList();\n\nfruits.insert('Apple' , 'head');\nfruits.insert('Banana' , 'Apple');\nfruits.insert('Pear' , 'Banana');\nfruits.insert('Grape' , 'Pear');\n\nconsole.log( fruits.display() );        // Apple\n                                        // Banana\n                                        // Pear\n                                        // Grape\n                                        \nconsole.log( fruits.dispReverse() );    // Grape\n                                        // Pear\n                                        // Banana\n                                        // Apple\n")])])]),t("h3",{attrs:{id:"_16-前端框架的diff算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-前端框架的diff算法"}},[n._v("#")]),n._v(" 16 前端框架的diff算法")]),n._v(" "),t("p",[n._v("vue2.0加入了virtual dom，有点向react靠拢的意思。vue的diff位于patch.js文件中，复杂度为O(n)。\n听大神说了解diff过程可以让我们更高效的使用框架，工作和女朋友都更加好找了，我们赶快了解哈~。\n了解diff过程，我们先从虚拟dom开始。")]),n._v(" "),t("p",[n._v("所谓的virtual dom，也就是虚拟节点。它通过JS的Object对象模拟DOM中的节点，然后再通过特定的render方法将其渲染成真实的DOM节点\ndom diff 则是通过JS层面的计算，返回一个patch对象，即补丁对象，在通过特定的操作解析patch对象，完成页面的重新渲染，")]),n._v(" "),t("p",[n._v("实现步骤\n用JavaScript对象模拟DOM\n把此虚拟DOM转成真实DOM并插入页面中\n如果有事件发生修改了虚拟DOM\n比较两棵虚拟DOM树的差异，得到差异对象\n把差异对象应用到真正的DOM树上")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class crtateElement {\n    constructor (el, attr, child) {\n        this.el = el\n        this.attrs = attr\n        this.child = child || []\n    }\n    render () { \n        let virtualDOM =  document.createElement(this.el)\n        // attr是个对象所以要遍历渲染\n        for (var attr in this.attrs) {\n            virtualDOM.setAttribute(attr, this.attrs[attr])\n        }\n\n        // 深度遍历child\n        this.child.forEach(el => {\n            console.log(el instanceof crtateElement)\n            //如果子节点是一个元素的话，就调用它的render方法创建子节点的真实DOM，如果是一个字符串的话，创建一个文件节点就可以了\n            // 判断一个对象是否是某个对象的实力\n            let childElement = (el instanceof crtateElement) ? el.render() : document.createTextNode(el);\n            virtualDOM.appendChild(childElement);\n        });\n        return virtualDOM\n    }\n}\nfunction element (el, attr, child) {\n    return new crtateElement(el, attr, child)\n}\n\nmodule.exports = element\n")])])]),t("p",[n._v("用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档当中")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let element = require('./element') \n\nlet myobj = {\n    \"class\": 'big_div'\n}\nlet ul = element('div',myobj,[\n    '我是文字',\n    element('div',{'id': 'xiao'},['1']),\n    element('div',{'id': 'xiao1'},['2']),\n    element('div',{'id': 'xiao2'},['3']),\n])\nconsole.log(ul)\nul = ul.render()\ndocument.body.appendChild(ul)\n")])])]),t("p",[n._v("比较两棵DOM树的差异是Virtual DOM算法最核心的部分.简单的说就是新旧虚拟dom 的比较，如果有差异就以新的为准，然后再插入的真实的dom中，重新渲染。")]),n._v(" "),t("p",[n._v("比较只会在同层级进行, 不会跨层级比较。\n比较后会出现四种情况：\n1、此节点是否被移除 -> 添加新的节点\n2、属性是否被改变 -> 旧属性改为新属性\n3、文本内容被改变-> 旧内容改为新内容\n4、节点要被整个替换  -> 结构完全不相同 移除整个替换\n看diff.js 的简单代码实现，下面都有相应的解释说明")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let utils = require('./utils');\n\nlet keyIndex = 0;\nfunction diff(oldTree, newTree) {\n    //记录差异的空对象。key就是老节点在原来虚拟DOM树中的序号，值就是一个差异对象数组\n    let patches = {};\n    keyIndex = 0;  // 儿子要起另外一个标识\n    let index = 0; // 父亲的表示 1 儿子的标识就是1.1 1.2\n    walk(oldTree, newTree, index, patches);\n    return patches;\n}\n//遍历\nfunction walk(oldNode, newNode, index, patches) {\n    let currentPatches = [];//这个数组里记录了所有的oldNode的变化\n    if (!newNode) {//如果新节点没有了，则认为此节点被删除了\n        currentPatches.push({ type: utils.REMOVE, index });\n        //如果说老节点的新的节点都是文本节点的话\n    } else if (utils.isString(oldNode) && utils.isString(newNode)) {\n        //如果新的字符符值和旧的不一样\n        if (oldNode != newNode) {\n            ///文本改变 \n            currentPatches.push({ type: utils.TEXT, content: newNode });\n        }\n    } else if (oldNode.tagName == newNode.tagName) {\n        //比较新旧元素的属性对象\n        let attrsPatch = diffAttr(oldNode.attrs, newNode.attrs);\n        //如果新旧元素有差异 的属性的话\n        if (Object.keys(attrsPatch).length > 0) {\n            //添加到差异数组中去\n            currentPatches.push({ type: utils.ATTRS, attrs: attrsPatch });\n        }\n        //自己比完后再比自己的儿子们\n        diffChildren(oldNode.children, newNode.children, index, patches, currentPatches);\n    } else {\n        currentPatches.push({ type: utils.REPLACE, node: newNode });\n    }\n    if (currentPatches.length > 0) {\n      patches[index] = currentPatches;\n    }\n}\n//老的节点的儿子们 新节点的儿子们 父节点的序号 完整补丁对象 当前旧节点的补丁对象\nfunction diffChildren(oldChildren, newChildren, index, patches, currentPatches) {\n    oldChildren.forEach((child, idx) => {\n        walk(child, newChildren[idx], ++keyIndex, patches);\n    });\n}\nfunction diffAttr(oldAttrs, newAttrs) {\n    let attrsPatch = {};\n    for (let attr in oldAttrs) {\n        //如果说老的属性和新属性不一样。一种是值改变 ，一种是属性被删除 了\n        if (oldAttrs[attr] != newAttrs[attr]) {\n            attrsPatch[attr] = newAttrs[attr];\n        }\n    }\n    for (let attr in newAttrs) {\n        if (!oldAttrs.hasOwnProperty(attr)) {\n            attrsPatch[attr] = newAttrs[attr];\n        }\n    }\n    return attrsPatch;\n}\nmodule.exports = diff;\n")])])]),t("p",[n._v("其中有个需要注意的是新旧虚拟dom比较的时候，是先同层比较，同层比较完看看时候有儿子，有则需要继续比较下去，直到没有儿子。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let keyIndex = 0;\nlet utils = require('./utils');\nlet allPatches;//这里就是完整的补丁包\nfunction patch(root, patches) {\n    allPatches = patches;\n    walk(root);\n}\nfunction walk(node) {\n    let currentPatches = allPatches[keyIndex++];\n    (node.childNodes || []).forEach(child => walk(child));\n    if (currentPatches) {\n        doPatch(node, currentPatches);\n    }\n}\nfunction doPatch(node, currentPatches) {\n    currentPatches.forEach(patch => {\n        switch (patch.type) {\n            case utils.ATTRS:\n                for (let attr in patch.attrs) {\n                    let value = patch.attrs[attr];\n                    if (value) {\n                        utils.setAttr(node, attr, value);\n                    } else {\n                        node.removeAttribute(attr);\n                    }\n                }\n                break;\n            case utils.TEXT:\n                node.textContent = patch.content;\n                break;\n            case utils.REPLACE:\n                let newNode = (patch.node instanceof Element) ? path.node.render() : document.createTextNode(path.node);\n                node.parentNode.replaceChild(newNode, node);\n                break;\n            case utils.REMOVE:\n                node.parentNode.removeChild(node);\n                break;\n        }\n    });\n}\nmodule.exports = patch;\n")])])]),t("h3",{attrs:{id:"_17-js实现二叉树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-js实现二叉树"}},[n._v("#")]),n._v(" 17 js实现二叉树")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//定义节点\nclass Node {\n    constructor(data){\n        this.root = this;\n        this.data = data;\n        this.left = null;\n        this.right = null\n    }\n}\n//创建二叉搜索树(BST)）\nclass BinarySearchTree {\n    constructor(){\n    this.root = null\n    }\n    //插入节点\n    insert(data){\n        const newNode = new Node(data);\n        const insertNode = (node,newNode) => {\n            if (newNode.data < node.data){\n                if(node.left === null){\n                    node.left = newNode\n                }else {\n                    insertNode(node.left,newNode)\n                }\n            }else {\n                if(node.right === null){\n                    node.right = newNode\n                }else{\n                    insertNode(node.right,newNode)\n                }\n\n            }\n        };\n        if(!this.root){\n            this.root = newNode\n        }else {\n            insertNode(this.root,newNode)\n\n        }\n    }\n    //中序遍历\n    inOrder(){\n        let backs = [];\n        const inOrderNode = (node,callback) => {\n            if(node !== null){\n                inOrderNode(node.left,callback);\n                backs.push(callback(node.data));\n                inOrderNode(node.right,callback)\n            }\n        };\n        inOrderNode(this.root,callback);\n        function callback(v){\n            return v\n        }\n        return backs\n    }\n    //前序遍历\n    preOrder(){\n        let backs = [];\n        const preOrderNode = (node,callback) => {\n            if(node !== null){\n                backs.push(callback(node.data));\n                preOrderNode(node.left,callback);\n                preOrderNode(node.right,callback)\n            }\n        };\n        preOrderNode(this.root,callback);\n        function callback(v){\n            return v\n        }\n        return backs\n    }\n    //后序遍历\n    postOrder(){\n        let backs = [];\n        const postOrderNode = (node,callback) => {\n            if(node !== null){\n                postOrderNode(node.left,callback);\n                postOrderNode(node.right,callback);\n                backs.push(callback(node.data))\n            }\n        };\n        postOrderNode(this.root,callback);\n        function callback(v){\n            return v\n        }\n        return backs\n    }\n    //查找最小值\n    getMin(node){\n        const minNode = node => {\n            return node? (node.left? minNode(node.left):node):null\n        };\n        return minNode( node || this.root)\n    }\n    //查找最大值\n    getMax(node){\n        const minNode = node => {\n            return node? (node.right? minNode(node.right):node):null\n        };\n        return minNode(node || this.root)\n    }\n    //查找特定值\n    find(data){\n        const findNode = (node,data) => {\n            if(node===null) return false;\n            if(node.data===data) return node;\n            return findNode((data < node.data)? node.left: node.right,data)\n        };\n        return findNode(this.root,data)\n\n    }\n    //删除节点\n    remove(data){\n        const removeNode = (node,data) => {\n            if(node === null) return null;\n            if(node.data === data){\n                if(node.left === null && node.right === null) return null;\n                if(node.left === null) return node.right;\n                if(node.right === null) return node.left;\n                if(node.left !==null && node.right !==null){\n                let _node = this.getMin(node.right);\n                node.data = _node.data;\n                node.right = removeNode(node.right,data);\n                return node\n                }\n            } else if(data < node.data){\n                node.left=removeNode(node.left,data);\n                return node\n            } else {\n                node.right=removeNode(node.right,data);\n                return node\n            }\n        };\n        return removeNode(this.root,data)\n    }\n}\n")])])]),t("h3",{attrs:{id:"_18-下面这段程序的结果是？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_18-下面这段程序的结果是？"}},[n._v("#")]),n._v(" 18 下面这段程序的结果是？")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("for (var i = 0; i < 5; i++) {\n setTimeout(function() {\n  console.log(i);\n }, 1000);\n}\n \nconsole.log(i);\n")])])]),t("ul",[t("li",[t("p",[n._v("只要你对 JS 中同步和异步代码的区别、变量作用域、闭包等概念有正确的理解，就知道正确答案是5,5,5,5,5,5；")])]),n._v(" "),t("li",[t("p",[n._v("若用->表示其前后的两次输出之间有 1 秒，而逗号表示间隔可以忽略，结果是？ 循环执行过程中，几乎同时设置了 5 个定时器，一般情况下，这些定时器都会在 1 秒之后触发，而循环完的输出是立即执行的, 所以结果是 5 -> 5,5,5,5,5；")])]),n._v(" "),t("li",[t("p",[n._v("如果期望代码的输出变成：5 -> 0,1,2,3,4，该怎么改造代码？ 巧妙的利用 IIFE（声明即执行的函数表达式）来解决闭包造成的问题, 相当于把i赋值\b给了j这个局部变量:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("for (var i = 0; i < 5; i++) {\n(function(j) { \n  setTimeout(function() {\n  console.log(j);\n  }, 1000);\n})(i);\n}\nconsole.log(i);\n")])])])]),n._v(" "),t("li",[t("p",[n._v("有没有更符合直觉的做法？ 利用 JS 中基本类型的参数传递是按值传递的特征, 对循环体稍做手脚，让负责输出的那段代码能拿到每次循环的 i 值即可:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var print = function (i) {\nsetTimeout(function() {\n  console.log(i);\n}, 1000);\n};\nfor (var i = 0; i < 5; i++) {\n  print(i); // 传递到 print 的 i\b 值被复制了\n}\nconsole.log(i);\n")])])])]),n._v(" "),t("li",[t("p",[n._v("如果期望代码的输出变成 0 -> 1 -> 2 -> 3 -> 4 -> 5，并且要求原有的代码块中的循环和两处 console.log 不变，该怎么改造代码？")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("for (var i = 0; i < 5; i++) {\n  (function(j) {\n    setTimeout(function() {\n    console.log(j);\n    }, 1000 * j)); // 这里修改 0~4 的定时器时间\n  })(i);\n}\n\nsetTimeout(function() { // 这里增加定时器，超时设置为 5 秒\n  console.log(i);\n}, 1000 * i);\n")])])])]),n._v(" "),t("li",[t("p",[n._v("有没有基于ES6 Promise 的解决方案 ?")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const tasks = [];\nfor (var i = 0; i < 5; i++) { \n  ((j) => {\n    tasks.push(new Promise((resolve) => {\n    setTimeout(() => {\n      console.log(j);\n      resolve(); // 一定要 resolve\n    }, 1000 * j); \n    }));\n  })(i);\n}\n\nPromise.all(tasks).then(() => {\n  setTimeout(() => {\n    console.log( i);\n  }, 1000); // 只需把超时设置为 1 秒\n});\n")])])])]),n._v(" "),t("li",[t("p",[n._v("把上面 i 的声明改成 let，怎么做？")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const tasks = [];\nfor (let i = 0; i < 5; i++) { \n  tasks.push(new Promise((resolve) => {\n    setTimeout(() => {\n      console.log(j);\n      resolve(); // 一定要 resolve\n    }, 1000 * j); \n  }));\n}\n\nPromise.all(tasks).then(() => {\n  setTimeout(() => {\n    console.log( i);\n  }, 1000); // 只需把超时设置为 1 秒\n});\n")])])])]),n._v(" "),t("li",[t("p",[n._v("有没有代码层次更好的做法？")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const tasks = []; // 存放异步操作的 Promise\nconst print = (i) => new Promise((resolve) => {\n  setTimeout(() => {\n    console.log(i);\n    resolve();\n  }, 1000 * i);\n});\n\n// 获得全部的异步操作\nfor (var i = 0; i < 5; i++) {\n  tasks.push(print(i));\n}\n\n// 输出最后的 i\nPromise.all(tasks).then(() => {\n  setTimeout(() => {\n    console.log(i);\n  }, 1000);\n});\n")])])])]),n._v(" "),t("li",[t("p",[n._v("如何使用 ES7 中的 async await 特性来让这段代码变的更简洁？")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("  const sleep = (t) => new Promise((resolve) => {\n    setTimeout(resolve, t);\n  });\n  \n  (async () => { \n    for (var i = 0; i < 5; i++) {\n      await sleep(1000);\n      console.log(i);\n    }\n    await sleep(1000);\n    console.log(i);\n  })();\n")])])])]),n._v(" "),t("li",[t("p",[n._v("还能优化吗？")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("  const sleep = (t) => new Promise((resolve) => {\n    setTimeout(resolve, t);\n  });\n  \n  const print = async () => { \n    for (let i = 0; i <= 5; i++) {\n      await sleep(1000);\n      console.log(i);\n    }\n  };\n\n  print();\n")])])]),t("h3",{attrs:{id:"_19-实现发布订阅"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_19-实现发布订阅"}},[n._v("#")]),n._v(" 19 实现发布订阅")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class EventEmitter {\n  constructor() {\n      // 事件对象，存放订阅的名字和事件\n      this.events = {};\n  }\n  // 订阅事件的方法\n  on(eventName,callback) {\n     if (!this.events[eventName]) {\n         // 注意时数据，一个名字可以订阅多个事件函数\n         this.events[eventName] = [callback]\n     } else  {\n        // 存在则push到指定数组的尾部保存\n         this.events[eventName].push(callback)\n     }\n  }\n  // 触发事件的方法\n  emit(eventName) {\n      // 遍历执行所有订阅的事件\n     this.events[eventName] && this.events[eventName].forEach(cb => cb());\n  }\n  // 移除订阅事件\n  removeListener(eventName, callback) {\n      if (this.events[eventName]) {\n          this.events[eventName] = this.events[eventName].filter(cb => cb != callback)\n      }\n  }\n  // 只执行一次订阅的事件，然后移除\n  once(eventName,callback) {\n      // 绑定的时fn, 执行的时候会触发fn函数\n      let fn = () => {\n         callback(); // fn函数中调用原有的callback\n         this.removeListener(eventName,fn); // 删除fn, 再次执行的时候之后执行一次\n      }\n      this.on(eventName,fn)\n  }\n}\n")])])])])])])}),[],!1,null,null,null);e.default=r.exports}}]);