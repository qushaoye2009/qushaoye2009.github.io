(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{285:function(a,t,v){"use strict";v.r(t);var _=v(28),e=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"基础知识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基础知识"}},[a._v("#")]),a._v(" 基础知识")]),a._v(" "),v("p",[a._v("本章将从最简单的讲起，循序渐进、由浅入深，力求清晰易懂地全面介绍 JS基础特性和语法。")]),a._v(" "),v("h2",{attrs:{id:"关于js"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关于js"}},[a._v("#")]),a._v(" 关于js")]),a._v(" "),v("p",[a._v("JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。")]),a._v(" "),v("p",[a._v("JavaScript 本身只能用来做一些数学和逻辑运算，不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以它只合适嵌入到更大型的应用程序环境，去调用宿主环境提供的底层 API。")]),a._v(" "),v("h2",{attrs:{id:"js的宿主环境"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js的宿主环境"}},[a._v("#")]),a._v(" JS的宿主环境")]),a._v(" "),v("p",[a._v("目前，已经嵌入 JavaScript 的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。")]),a._v(" "),v("p",[a._v("JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（一系列具有各种功能的对象比如Array、Date、Math等）。")]),a._v(" "),v("p",[a._v("除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，它提供的额外 API 可以分成三大类。")]),a._v(" "),v("ul",[v("li",[a._v("浏览器控制类：操作浏览器")]),a._v(" "),v("li",[a._v("DOM 类：操作网页的各种元素")]),a._v(" "),v("li",[a._v("Web 类：实现互联网的各种功能")])]),a._v(" "),v("p",[a._v("如果宿主环境是服务器，则会提供各种操作系统的 API，比如文件操作 API、网络通信 API等等。这些你都可以在 Node 环境中找到。")]),a._v(" "),v("h2",{attrs:{id:"js的使用领域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js的使用领域"}},[a._v("#")]),a._v(" JS的使用领域")]),a._v(" "),v("p",[a._v("JavaScript 的发明目的，就是作为浏览器的内置脚本语言，为网页开发者提供操控浏览器的能力。它是目前唯一一种通用的浏览器脚本语言，所有浏览器都支持。")]),a._v(" "),v("p",[a._v("近年来，JavaScript 的使用范围，慢慢超越了浏览器，正在向通用的系统语言发展。")]),a._v(" "),v("ul",[v("li",[a._v("浏览器的平台化： 随着 HTML5 的出现，浏览器本身的功能越来越强，不再仅仅能浏览网页，而是越来越像一个平台，JavaScript 因此得以调用许多系统功能；")]),a._v(" "),v("li",[a._v("Node 项目：用于开发服务器端的大型项目，网站的前后端都用 JavaScript 开发已经成为了现实；")]),a._v(" "),v("li",[a._v("移动平台开发：Facebook 公司的 React Native 项目以及基于vue的weex让JS成为越来越多手机应用的开发语言;")]),a._v(" "),v("li",[a._v("跨平台的桌面应用程序：Mozilla 的 Open Web Apps 项目、Google 的 Chrome App 项目、GitHub 的 Electron 项目、以及 TideSDK 项目，都可以用来编写运行于 Windows、Mac OS 和 Android 等多个桌面平台的程序，不依赖浏览器。")])]),a._v(" "),v("h2",{attrs:{id:"基本语法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本语法"}},[a._v("#")]),a._v(" 基本语法")]),a._v(" "),v("h3",{attrs:{id:"语句"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#语句"}},[a._v("#")]),a._v(" 语句")]),a._v(" "),v("p",[a._v("JavaScript 程序的执行单位为行，每一行就是一个语句(为了完成某种任务而进行的操作)，如：")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = 1 + 3;\n")])])]),v("p",[a._v("这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。")]),a._v(" "),v("p",[a._v("1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。")]),a._v(" "),v("p",[a._v("语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = 1 + 3 ; var b = 'abc';\n")])])]),v("h3",{attrs:{id:"变量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#变量"}},[a._v("#")]),a._v(" 变量")]),a._v(" "),v("h4",{attrs:{id:"变量的概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#变量的概念"}},[a._v("#")]),a._v(" 变量的概念")]),a._v(" "),v("p",[a._v("变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = 1;\n")])])]),v("p",[a._v("上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a。以后，引用变量名a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。")]),a._v(" "),v("ul",[v("li",[a._v("JS 的变量名区分大小写，A和a是两个不同的变量;")]),a._v(" "),v("li",[a._v("如果只是声明变量而没有赋值，则该变量的值是undefined;")]),a._v(" "),v("li",[a._v("JS 是一种动态类型语言，变量的类型没有限制，可以随时更改类型;")])]),a._v(" "),v("p",[a._v("ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。let不允许在相同作用域内，重复声明同一个变量。")]),a._v(" "),v("p",[a._v("let实际上为 JavaScript 新增了块级作用域。")]),a._v(" "),v("p",[a._v("const声明一个只读的常量。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。")]),a._v(" "),v("p",[a._v("const的作用域与let命令相同：只在声明所在的块级作用域内有效")]),a._v(" "),v("h4",{attrs:{id:"变量的提升"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#变量的提升"}},[a._v("#")]),a._v(" 变量的提升")]),a._v(" "),v("p",[a._v("JS 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("console.log(a);\nvar a = 1;\n")])])]),v("p",[a._v("因为存在变量提升，真正运行的是下面的代码:")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a;\nconsole.log(a);\na = 1;\n")])])]),v("p",[a._v("var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。")]),a._v(" "),v("p",[a._v("为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。")]),a._v(" "),v("h4",{attrs:{id:"暂时性死区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#暂时性死区"}},[a._v("#")]),a._v(" 暂时性死区")]),a._v(" "),v("p",[a._v("ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。")]),a._v(" "),v("p",[a._v("在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。")]),a._v(" "),v("p",[a._v("“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。")]),a._v(" "),v("p",[a._v("ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。")]),a._v(" "),v("h4",{attrs:{id:"解构赋值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解构赋值"}},[a._v("#")]),a._v(" 解构赋值")]),a._v(" "),v("p",[a._v("ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("let [a, b, c] = [1, 2, 3];\n")])])]),v("p",[a._v("本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。")]),a._v(" "),v("p",[a._v("只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。")]),a._v(" "),v("p",[a._v("解构赋值允许指定默认值。")]),a._v(" "),v("p",[a._v("对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。")]),a._v(" "),v("h3",{attrs:{id:"标识符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标识符"}},[a._v("#")]),a._v(" 标识符")]),a._v(" "),v("p",[a._v("标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。")]),a._v(" "),v("p",[a._v("标识符命名规则如下：")]),a._v(" "),v("ul",[v("li",[a._v("第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。")]),a._v(" "),v("li",[a._v("第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。")])]),a._v(" "),v("h3",{attrs:{id:"注释"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#注释"}},[a._v("#")]),a._v(" 注释")]),a._v(" "),v("p",[a._v("源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。JavaScript 提供两种注释的写法：一种是单行注释，用//起头；另一种是多行注释，放在/"),v("em",[a._v("和")]),a._v("/之间。")]),a._v(" "),v("p",[a._v("此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以"),a._v("也被视为合法的单行注释。需要注意的是，--\x3e只有在行首，才会被当成单行注释，否则会当作正常的运算。")]),a._v(" "),v("h3",{attrs:{id:"条件语句"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#条件语句"}},[a._v("#")]),a._v(" 条件语句")]),a._v(" "),v("p",[a._v("JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。")]),a._v(" "),v("p",[a._v("三元运算符 ? 可以被视为if...else...的简写形式，")]),a._v(" "),v("h3",{attrs:{id:"循环语句"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#循环语句"}},[a._v("#")]),a._v(" 循环语句")]),a._v(" "),v("p",[a._v("循环语句用于重复执行某个操作，它有多种形式：")]),a._v(" "),v("ul",[v("li",[a._v("While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。")]),a._v(" "),v("li",[a._v("for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。")]),a._v(" "),v("li",[a._v("do...while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。")]),a._v(" "),v("li",[a._v("break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。")])]),a._v(" "),v("h3",{attrs:{id:"标签"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标签"}},[a._v("#")]),a._v(" 标签")]),a._v(" "),v("p",[a._v("JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置。")]),a._v(" "),v("p",[a._v("标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。")]),a._v(" "),v("p",[a._v("标签通常与break语句和continue语句配合使用，跳出特定的循环。")])])}),[],!1,null,null,null);t.default=e.exports}}]);