(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{273:function(a,e,t){"use strict";t.r(e);var s=t(28),v=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"使用nodejs开发接口服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用nodejs开发接口服务"}},[a._v("#")]),a._v(" 使用nodejs开发接口服务")]),a._v(" "),t("p",[a._v("针对有追求的开发者或是想创业的，我们基于koa这个node.js最主流的框架和我们实际的项目，讲解后端接口开发的必备知识技能，以及如何提升后端服务的研发效率和服务稳定性。")]),a._v(" "),t("p",[a._v("对应的视频教程请访问： "),t("a",{attrs:{href:"http://t.yibiankeji.com/",target:"_blank",rel:"noopener noreferrer"}},[a._v("http://t.yibiankeji.com/"),t("OutboundLink")],1),a._v("。")]),a._v(" "),t("h2",{attrs:{id:"_01-课程简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_01-课程简介"}},[a._v("#")]),a._v(" 01 课程简介")]),a._v(" "),t("p",[a._v("虽然前面大家已经接触过nodejs了，但是要想深入掌握nodejs, 还需要进一步学习。本系列课的目的就是通过项目实战帮助大家掌握使用node\bjs实现后端开发常见需求和核心原理。")]),a._v(" "),t("h3",{attrs:{id:"_1-1-关于nodejs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-关于nodejs"}},[a._v("#")]),a._v(" 1.1 关于nodejs")]),a._v(" "),t("p",[a._v("中文官网为：http://nodejs.cn/，英文官网为：https://nodejs.org/，入门文字教程 https://www.runoob.com/nodejs/nodejs-tutorial.html。")]),a._v(" "),t("p",[a._v("官网对其介绍为：Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时。")]),a._v(" "),t("p",[a._v("从某种意义上来说，Node.js 并不是一个从零开始编写的 JavaScript 运行时，它其实也是站在“巨人的肩膀”上进行了一系列的拼凑和封装得到的结果，它的高效离不开一些很牛的第三方程序和类库。")]),a._v(" "),t("p",[a._v("Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。")]),a._v(" "),t("p",[a._v("Node对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好，V8引擎执行Javascript的速度非常快，性能非常好。")]),a._v(" "),t("p",[a._v("Javascript是一个事件驱动语言，Node利用了这个优点，编写出可扩展性高的服务器。Node采用了一个称为“事件循环(event loop）”的架构，使得编写可扩展性高的服务器变得既容易又安全。")]),a._v(" "),t("p",[a._v("随着互联网的不断普及和Web的迅速发展，几家巨头公司开始了浏览器之战。微软推出了IE系列浏览器，Mozilla推出了Firefox浏览器，苹果推出了Safari浏览器，谷歌推出了Chrome浏览器。")]),a._v(" "),t("p",[a._v("微软认为IE6已经非常完善，几乎没有可改进之处，就解散了IE6的开发团队。而Google却认为支持现代Web应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行JavaScript的引擎性能还可提升10倍，于是自己偷偷开发了一个高性能的Javascript解析引擎，取名V8，并且开源。")]),a._v(" "),t("p",[a._v("话说有个叫Ryan Dahl的歪果仁，他的工作是用C/C++写高性能Web服务。对于高性能，异步IO、事件驱动是基本原则，但是用C/C++写就太痛苦了，于是这位仁兄开始设想用高级语言开发Web服务。")]),a._v(" "),t("p",[a._v("他评估了很多种高级语言，发现很多语言虽然同时提供了同步IO和异步IO，但是开发人员一旦用了同步IO，他们就再也懒得写异步IO了，所以，最终，Ryan瞄向了JS。因为JavaScript是单线程执行，根本不能进行同步IO操作，只能使用异步IO。")]),a._v(" "),t("p",[a._v("另一方面，因为V8是开源的高性能JavaScript引擎，Google投资去优化V8，而他只需拿来改造一下。")]),a._v(" "),t("p",[a._v("于是在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。")]),a._v(" "),t("h3",{attrs:{id:"_1-2-浏览器端js和node端js的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-浏览器端js和node端js的区别"}},[a._v("#")]),a._v(" 1.2 浏览器端JS和Node端JS的区别")]),a._v(" "),t("p",[a._v("相同点就是都使用了Javascript这门语言来开发。")]),a._v(" "),t("p",[a._v("浏览器端的JS，受制于浏览器提供的接口。比如浏览器提供一个弹对话框的Api，那么JS就能弹出对话框。浏览器为了安全考虑，对文件操作，网络操作，操作系统交互等功能有严格的限制，所以在浏览器端的JS功能无法强大，就像是压在五行山下的孙猴子。")]),a._v(" "),t("p",[a._v("NodeJs完全没有了浏览器端的限制，让Js拥有了文件操作，网络操作，进程操作等功能，和Java，Python，Php等语言已经没有什么区别了。")]),a._v(" "),t("p",[a._v("而且由于底层使用性能超高的V8引擎来解析执行，和天然的异步IO机制，让我们编写高性能的Web服务器变得轻而易举。Node端的JS就像是被唐僧解救出来的齐天大圣一样，法力无边。")]),a._v(" "),t("h3",{attrs:{id:"_1-3-nodejs的事件驱动和异步io"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-nodejs的事件驱动和异步io"}},[a._v("#")]),a._v(" 1.3 NodeJS的事件驱动和异步IO")]),a._v(" "),t("p",[a._v("NodeJS在用户代码层，只启动一个线程来运行用户的代码。每当遇到耗时的IO操作，比如文件读写，网络请求，则将耗时操作丢给底层的事件循环去执行，而自己则不会等待，继续执行下面的代码。")]),a._v(" "),t("p",[a._v("当底层的事件循环执行完耗时IO时，会执行我们的回调函数来作为通知。")]),a._v(" "),t("p",[a._v("同步就是你去银行排队办业务，排队的时候啥也不能干(阻塞)；异步就是你去银行用取号机取了一个号，此时你可以自由的做其他事情，到你的时候会用大喇叭对你进行事件通知。")]),a._v(" "),t("p",[a._v("而银行系统相当于底层的事件循环，不断的处理耗时的业务(IO)。")]),a._v(" "),t("p",[a._v("但是NodeJs只有一个线程用来执行用户代码，如果耗时的是CPU计算操作，比如for循环100000000次，那么在循环的过程中，下面的代码将会无法执行，阻塞了唯一的一个线程。")]),a._v(" "),t("p",[a._v("所以，Node适合大并发的IO处理，不适合CPU密集型的计算操作。Web开发大部分都是耗时IO操作，所以Node非常适合进行Web开发。")]),a._v(" "),t("p",[a._v("如果真的遇到了CPU密集的计算，比如从1亿个用户中计算出哪些人和你兴趣相投的这个功能，就非常耗CPU，那这个功能就交由C++，C，Go，Java这些语言实现。像淘宝，京东这种大型网站绝对不是一种语言就可以实现的。")]),a._v(" "),t("p",[a._v("语言只是工具，让每一种语言做它最擅长的事，才能构建出稳定，强大的系统。")]),a._v(" "),t("h3",{attrs:{id:"_1-4-npm和nodejs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-npm和nodejs"}},[a._v("#")]),a._v(" 1.4 npm和nodejs")]),a._v(" "),t("p",[a._v("npm是Nodejs自带的包管理器，当你安装Node的时候就自动安装了npm。通俗的讲，当我们想使用一个功能的时候，而Node本身没有提供，那么我们就可以从npm上去搜索并下载这个模块。")]),a._v(" "),t("p",[a._v("每个开发语言都有自己的包管理器，比如，java有maven，python有pip。而npm是目前世界上生态最丰富，可用模块最多的一个社区，没有之一。")]),a._v(" "),t("p",[a._v("基本上，你所能想到的功能都不用自己手写了，它已经在npm上等着你下载使用了。npm的海量模块，使得我们开发复杂的NodeJs的程序变得更为简单。")]),a._v(" "),t("h3",{attrs:{id:"_1-5-node-js和chrome-v8-引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-node-js和chrome-v8-引擎"}},[a._v("#")]),a._v(" 1.5 Node.js和Chrome V8 引擎")]),a._v(" "),t("p",[a._v("随着Web相关技术的发展，JavaScript所要承担的工作也越来越多，早就超越了“表单验证”的范畴，这就更需要快速的解析和执行JavaScript脚本。")]),a._v(" "),t("p",[a._v("而JavaScript本质上是一种解释型语言，与编译型语言不同的是它需要边执行边解析，而编译型语言在执行时已经完成编译，可直接执行，有更快的执行速度。")]),a._v(" "),t("p",[a._v("V8引擎就是为解决这一问题而生，在node中也是采用该引擎来解析JavaScript。V8引擎是一个JavaScript引擎实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了开源。")]),a._v(" "),t("p",[a._v("V8使用C++开发，在运行JavaScript之前，相比其它的JavaScript的引擎转换成字节码或解释执行，V8将其编译成原生机器码，并且使用了如内联缓存（inline caching）等方法来提高性能。")]),a._v(" "),t("p",[a._v("有了这些功能，JavaScript程序在V8引擎下的运行速度媲美二进制程序。V8支持众多操作系统，如windows、linux、android等，也支持其他硬件架构，如IA32,X64,ARM等，具有很好的可移植和跨平台特性。")]),a._v(" "),t("p",[a._v("JavaScript引擎的执行过程大致是： 源代码-→抽象语法树-→字节码-→JIT-→本地代码(V8引擎没有中间字节码)。")]),a._v(" "),t("p",[a._v("V8 可以单独运行，也可以嵌入 C++ 应用当中。和其他的 JavaScript 引擎一样，V8 会编译、执行 JavaScript 代码，并一样会管理内存、垃圾回收等。")]),a._v(" "),t("p",[a._v("V8 开发小组由一群程序语言专家组成，其中核心工程师 Lars Bak 之前在 Sun 公司工作，专注于 Java 虚拟机加速技术的研究，产出了 HotSpot，除此之外，他还曾开发了 Strongtalk1。所以，V8 的代码里面蕴含了从 HotSpot 和 Strongtalk 中汲取的精髓。")]),a._v(" "),t("p",[a._v("该研发小组从 2006 年开始研发 V8，原因是当年市面上的各种 JavaScript 引擎效率都比较低下。在 Lars Bak 等人的贡献下，JavaScript 引擎添加了新的一员——Chrome V8，并且效率非常高。")]),a._v(" "),t("p",[a._v("V8 在开发的过程中也一直追着 ECMAScript 发布的脚步，才有了 Node.js 能及时跟上 ECMAScript 最新语法的情况，如基本上完成了对 ES6 的支持，而且最新版也对 async/await 函数进行了支持。")]),a._v(" "),t("p",[a._v("Node.js 与 V8 实际上看起来更像是一对情侣，而不仅仅是 Node.js 一厢情愿地使用 V8 作为自己的底层支持。")]),a._v(" "),t("p",[a._v("在 Chrome V8 的博客中曾经有一篇文章名为《V8 ❤ Node.js》。Node.js 在几年发展中的流行度稳步增长，于是有了 V8 的“姑娘，你成功引起了我的注意”。现在 V8 也有一些工作是为 Node.js 而做的：")]),a._v(" "),t("ul",[t("li",[a._v("在 Chrome 开发者工具中可以调试 Node.js；")]),a._v(" "),t("li",[a._v("加速 ES6；")]),a._v(" "),t("li",[a._v("针对 Node.js vm 模块和 REPL 的一些修复；")]),a._v(" "),t("li",[a._v("Async / await。")])]),a._v(" "),t("p",[a._v("V8引擎在执行JavaScript的过程中，主要有两个阶段：编译和运行，与C++的执行前完全编译不同的是，JavaScript需要在用户使用时完成编译和执行。")]),a._v(" "),t("p",[a._v("在V8中，JavaScript相关代码并非一下完成编译的，而是在某些代码需要执行时，才会进行编译，这就提高了响应时间，减少了时间开销。")]),a._v(" "),t("p",[a._v("在V8引擎中，源代码先被解析器转变为抽象语法树(AST)，然后使用JIT编译器的全代码生成器从AST直接生成本地可执行代码。这个过程不同于JAVA先生成字节码或中间表示，减少了AST到字节码的转换时间，提高了代码的执行速度。")]),a._v(" "),t("p",[a._v("但由于缺少了转换为字节码这一中间过程，也就减少了优化代码的机会。")]),a._v(" "),t("p",[a._v("在V8引擎启动时，需要构建JavaScript运行环境，需要加载很多内置对象，同时也需要建立内置的函数，如Array，String，Math等。")]),a._v(" "),t("p",[a._v("为了使V8更加整洁，加载对象和建立函数等任务都是使用JavaScript文件来实现的，V8引擎负责提供机制来支持，就是在编译和执行JavaScript前先加载这些文件。")]),a._v(" "),t("p",[a._v("V8引擎需要编译和执行这些内置的JavaScript代码，同时使用堆等来保存执行过程中创建的对象、代码等，这些都需要时间。")]),a._v(" "),t("p",[a._v("为此，V8引入了快照机制。将这些内置的对象和函数加载之后的内存保存并序列化。序列化之后的结果很容易反序列化，经过快照机制的启动时间可以缩减几毫秒。")]),a._v(" "),t("p",[a._v("快照机制也可以将一些开发者认为需要的JavaScript文件序列化，以减少处理时间。不过快照机制的加载的代码不能被CrankShaft这样的编译器优化，可能会存在性能问题。")]),a._v(" "),t("h3",{attrs:{id:"_1-6-v8的扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-v8的扩展"}},[a._v("#")]),a._v(" 1.6 V8的扩展")]),a._v(" "),t("p",[a._v("JavaScript引擎的主要功能是解析和执行JavaScript代码，往往不能满足使用者多样化的需要，那么就可以增加扩展以提升它的能力。V8引擎有两种扩展机制：绑定和扩展。")]),a._v(" "),t("p",[a._v("JavaScript引擎绑定机制需要将扩展代码和JavaScript引擎一块编译和打包，不能根据需要在引擎启动后再动态注入这些本地代码。")]),a._v(" "),t("p",[a._v("在实际WEB开发中，开发者都是基于现有浏览器的，根本不可能介入到JavaScript引擎的编译中，绑定机制有很大的局限性，但其非常高效，适用于对性能要求较高的场景。")]),a._v(" "),t("p",[a._v("通过V8的基类Extension进行能力扩展，无需和V8引擎一起编译，可以动态为引擎增加功能特性，具有很大的灵活性。")]),a._v(" "),t("p",[a._v("Extension机制的大致思路就是，V8提供一个基类Extension和一个全局注册函数。")]),a._v(" "),t("h3",{attrs:{id:"_1-7-v8-与-javascriptcore"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-v8-与-javascriptcore"}},[a._v("#")]),a._v(" 1.7 V8 与 JavaScriptCore")]),a._v(" "),t("p",[a._v("JavaScriptCore引擎是WebKit中默认的JavaScript引擎，也是苹果开源的一个项目，应用较为广泛。最初，性能不是很好，从2008年开始了一系列的优化，重新实现了编译器和字节码解释器，使得引擎的性能有较大的提升。")]),a._v(" "),t("p",[a._v("随后内嵌缓存、基于正则表达式的JIT、简单的JIT及字节码解释器等技术引入进来，JavaScriptCore引擎也在不断的迭代和发展。")]),a._v(" "),t("p",[a._v("V8引擎自诞生之日起就以性能优化作为目标，引入了众多新技术，极大了带动了整个业界JavaScript引擎性能的快速发展。")]),a._v(" "),t("p",[a._v("总的来说，V8引擎较为激进，青睐可以提高性能的新技术，而JavaScriptCore引擎较为稳健，渐进式的改变着自己的性能。")]),a._v(" "),t("p",[a._v("JavaScriptCore 的大致流程为：源代码-→抽象语法树-→字节码-→JIT-→本地代码。")]),a._v(" "),t("p",[a._v("JavaScriptCore与V8有一些不同之处，其中最大的不同就是新增了字节码的中间表示，并加入了多层JIT编译器（如：简单JIT编译器、DFG JIT编译器、LLVM等）优化性能，不停的对本地代码进行优化。")]),a._v(" "),t("p",[a._v("在 V8 的 5.9 版本中，新增了一个 Ignition 字节码解释器，TurboFan 和 Ignition 结合起来共同完成JavaScript的编译，此后 V8 将与 JavaScriptCore 有大致相同的流程。")]),a._v(" "),t("h2",{attrs:{id:"_02-初始化项目"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_02-初始化项目"}},[a._v("#")]),a._v(" 02 初始化项目")]),a._v(" "),t("p",[a._v("虽然使用eggjs或thinkjs等框架能够帮助我们快速初始化一个node项目，但是不利于我们掌握框架背后的原理，特别是打牢node开发的基础，所以本节我们将带领大家使用Linux命令从0初始化我们的node项目。")]),a._v(" "),t("h3",{attrs:{id:"_2-1-安装node"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-安装node"}},[a._v("#")]),a._v(" 2.1 安装node")]),a._v(" "),t("p",[a._v("虽然在第一个系列课我们已经安装了nodejs，但是作为一个专业的node后端工程师，一般会使用nvm安装nodejs。")]),a._v(" "),t("p",[a._v("在不同系统下，安装 nodejs，都有很多种方法。主流的方式有：")]),a._v(" "),t("ul",[t("li",[a._v("直接到 nodejs 的官网https://nodejs.org/下载页 下载 对应系统下 自己想要的版本，成功后一路点击 安装即可, 如遇到问题，网上一搜就有对应的解决办法。")]),a._v(" "),t("li",[a._v("使用 nvm 安装，它是 Node Version Manager（Node版本管理器）的简称，用它可以方便的在机器上安装并维护多个Node的版本。")])]),a._v(" "),t("p",[a._v("在我们的日常开发中经常会遇到这种情况：手上有好几个项目，每个项目的需求不同，进而不同项目必须依赖不同版的 NodeJS 运行环境。如果没有一个合适的工具，这个问题将非常棘手。")]),a._v(" "),t("p",[a._v("nvm 应运而生，nvm 是 Mac 下的 node 管理工具，有点类似管理 Ruby 的 rvm，如果需要管理 Windows 下的 node，官方推荐使用 nvmw 或 nvm-windows。不过，nvm-windows 并不是 nvm 的简单移植，他们也没有任何关系。")]),a._v(" "),t("p",[a._v("nvm 的安装")]),a._v(" "),t("ul",[t("li",[a._v("win：对于windows系统，打开安装包下载地址，选择nvm-setup.zip，下载成功后运行解压出来的exe文件，一直点击下一步 到 安装完成即可。配置环境变量后，打开cmd 命令行，执行nvm -v命令后，出现一些相关的提示则说明安装成功了；")]),a._v(" "),t("li",[a._v("Mac：而在mac系统下安装，打开其 github 的README.md文档"),t("a",{attrs:{href:"https://github.com/creationix/nvm",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://github.com/creationix/nvm"),t("OutboundLink")],1),a._v("，找到最新版本的安装命令，如：")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash\n")])])]),t("p",[a._v("复制到本地终端执行即可, 然后通过nvm --version查看是否安装成功。")]),a._v(" "),t("p",[a._v("nvm 常用命令:")]),a._v(" "),t("ul",[t("li",[a._v("nvm ls-remote 列出全部可以安装的版本号;")]),a._v(" "),t("li",[a._v("nvm install 版本号  安装 给定的node版本，如v10.13.0;")]),a._v(" "),t("li",[a._v("nvm use 版本号 切换指定版本，切换效果是全局的 ;")]),a._v(" "),t("li",[a._v("nvm current 查看当前使用的版本")]),a._v(" "),t("li",[a._v("nvm ls 查看该系统已经安装的版本;")])]),a._v(" "),t("h3",{attrs:{id:"_2-2-npm-简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-npm-简介"}},[a._v("#")]),a._v(" 2.2 npm 简介")]),a._v(" "),t("p",[a._v("NPM是随同NodeJS一起安装的包管理工具，其使用场景有：")]),a._v(" "),t("ul",[t("li",[a._v("允许用户从NPM服务器下载别人编写的第三方包或命令行程序到本地使用")]),a._v(" "),t("li",[a._v("允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。")]),a._v(" "),t("li",[a._v("允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。")])]),a._v(" "),t("p",[a._v('由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 "npm -v" 来测试是否成功安装。')]),a._v(" "),t("p",[a._v("大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像,使用如下命令设置：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm config set registry https://registry.npm.taobao.org\n")])])]),t("p",[a._v("配置后可通过下面命令来验证是否成功")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm config get registry\n")])])]),t("p",[a._v("npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm install express          # 本地安装\nnpm install express -g   # 全局安装\n")])])]),t("p",[a._v("本地安装")]),a._v(" "),t("ul",[t("li",[a._v("将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。")]),a._v(" "),t("li",[a._v("可以通过 require() 来引入本地安装的包。\n全局安装")]),a._v(" "),t("li",[a._v("将安装包放在 /usr/local 下或者你 node 的安装目录。")]),a._v(" "),t("li",[a._v("可以直接在命令行里使用。")])]),a._v(" "),t("p",[a._v("如果你希望具备两者功能，则需要在两个地方安装它或使用 npm link。")]),a._v(" "),t("p",[a._v("可以使用以下命令来查看所有全局安装的模块：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm list -g\n")])])]),t("p",[a._v("可以使用以下命令来卸载 Node.js 模块:")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm uninstall express\n")])])]),t("p",[a._v("卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm list\n")])])]),t("p",[a._v("可以使用以下命令更新模块：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm update express\n")])])]),t("h3",{attrs:{id:"_2-3-package-json-文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-package-json-文件"}},[a._v("#")]),a._v(" 2.3 package.json 文件")]),a._v(" "),t("p",[a._v("创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm init\n")])])]),t("p",[a._v("package.json 位于模块的目录下，用于定义包的属性:")]),a._v(" "),t("ul",[t("li",[a._v("name - 包名。")]),a._v(" "),t("li",[a._v("version - 包的版本号。")]),a._v(" "),t("li",[a._v("description - 包的描述。")]),a._v(" "),t("li",[a._v("homepage - 包的官网 url 。")]),a._v(" "),t("li",[a._v("author - 包的作者姓名。")]),a._v(" "),t("li",[a._v("contributors - 包的其他贡献者姓名。")]),a._v(" "),t("li",[a._v("dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。")]),a._v(" "),t("li",[a._v("repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。")]),a._v(" "),t("li",[a._v("main - main 字段指定了程序的主入口文件，require('moduleName') 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。")]),a._v(" "),t("li",[a._v("keywords - 关键字")])]),a._v(" "),t("h3",{attrs:{id:"_2-4-创建目录及文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-创建目录及文件"}},[a._v("#")]),a._v(" 2.4 创建目录及文件")]),a._v(" "),t("ul",[t("li",[a._v("打开终端，默认进入的是用户所在的根目录；")]),a._v(" "),t("li",[a._v("创建并进入学习目录："),t("code",[a._v("mkdir study && cd study")])]),a._v(" "),t("li",[a._v("创建并进入项目目录："),t("code",[a._v("mkdir fs04-node-yb && cd fs04-node-yb")])]),a._v(" "),t("li",[a._v("创建package.json文件："),t("code",[a._v("npm init -f")]),a._v(" 直接按默认配置生成package.json文件；")]),a._v(" "),t("li",[a._v("创建服务器入口文件："),t("code",[a._v("touch app.js")]),a._v("；")]),a._v(" "),t("li",[a._v("编辑文件："),t("code",[a._v("vi app.js")]),a._v(";")])]),a._v(" "),t("p",[a._v("在英文输入法下按一下 i 键即进入编辑模式，输入如下内容：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const http = require('http');\nhttp.createServer((req, res) => {\n  res.writeHead(200,{'Content-Type': 'application/json;charset=utf-8;'});\n  res.write('{text: \"写代码很快乐啊!\"}');\n  res.end();\n}).listen(8888)；\n")])])]),t("p",[a._v("输完后，按esc进入指令模式，然后按 shift + : 两个键进入命令行模式，输入 wq 保存退出。")]),a._v(" "),t("p",[a._v('添加启动脚本： 在package.json 文件中的scripts 部分加入 "start": "node app", 如下所示:')]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "name": "fs04-node-yb",\n  "version": "1.0.0",\n  "description": "",\n  "main": "index.js",\n  "scripts": {\n    "start": "node app",\n    "test": "echo \\"Error: no test specified\\" && exit 1"\n  },\n  "keywords": [],\n  "author": "",\n  "license": "ISC",\n}\n')])])]),t("p",[a._v("启动项目，在项目根目录下输入：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm start\n")])])]),t("p",[a._v("把终端中的 http://localhost:8888/ 复制到浏览器即可看到网页显示：写代码很快乐。")]),a._v(" "),t("p",[a._v("Node.js 应用是由哪几部分组成的：")]),a._v(" "),t("ul",[t("li",[a._v("引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。")]),a._v(" "),t("li",[a._v("创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。")]),a._v(" "),t("li",[a._v("接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。")])]),a._v(" "),t("p",[a._v("分析Node.js 的 HTTP 服务器：")]),a._v(" "),t("ul",[t("li",[a._v("第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。")]),a._v(" "),t("li",[a._v("接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数，指定这个 HTTP 服务器监听的端口号")])]),a._v(" "),t("h3",{attrs:{id:"_2-5-提交代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-提交代码"}},[a._v("#")]),a._v(" 2.5 提交代码")]),a._v(" "),t("p",[a._v("首先，添加 .gitignore 文件，不要把 node_modules 下的文件提交到仓库。")]),a._v(" "),t("p",[a._v("其次，在GitHub上添加一个fs04-node-yb的项目，然后依次输入以下命令：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("git init \ngit add .\ngit commint -m 'first commit'\ngit remote add origin https://github.com/kongwutw/fs04-node-yb.git\ngit push -u origin master\n")])])]),t("h2",{attrs:{id:"_03-node基础用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_03-node基础用法"}},[a._v("#")]),a._v(" 03 node基础用法")]),a._v(" "),t("p",[a._v("本节我们将讲解一些node的基础API及其原理。")]),a._v(" "),t("h3",{attrs:{id:"_3-1-node-js-repl-交互式解释器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-node-js-repl-交互式解释器"}},[a._v("#")]),a._v(" 3.1 Node.js REPL(交互式解释器)")]),a._v(" "),t("p",[a._v("Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。")]),a._v(" "),t("p",[a._v("Node 自带了交互式解释器，可以执行以下任务：")]),a._v(" "),t("ul",[t("li",[a._v("读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。")]),a._v(" "),t("li",[a._v("执行 - 执行输入的数据结构")]),a._v(" "),t("li",[a._v("打印 - 输出结果")]),a._v(" "),t("li",[a._v("循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。")]),a._v(" "),t("li",[a._v("Node 的交互式解释器可以很好的调试 Javascript 代码。")])]),a._v(" "),t("p",[a._v("我们可以输入以下命令来启动 Node 的终端：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("node\n")])])]),t("h3",{attrs:{id:"_3-2-node-js-回调函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-node-js-回调函数"}},[a._v("#")]),a._v(" 3.2 Node.js 回调函数")]),a._v(" "),t("p",[a._v("Node.js 异步编程的直接体现就是回调,异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。")]),a._v(" "),t("p",[a._v("回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。")]),a._v(" "),t("p",[a._v("例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。")]),a._v(" "),t("p",[a._v("回调函数一般作为函数的最后一个参数出现：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function foo1(name, age, callback) { }\n")])])]),t("ul",[t("li",[a._v("阻塞代码实例\n在根目录下创建一个文件 test.txt ，内容如下：")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("易编网--最好的JS全栈培训\n")])])]),t("p",[a._v("把 app.js 文件改成：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('var fs = require("fs");\nvar data = fs.readFileSync(\'test.txt\');\nconsole.log(data.toString());\nconsole.log("程序执行结束!");\n')])])]),t("p",[a._v("以上代码执行结果如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("$ node app.js\n易编网--最好的JS全栈培训\n程序执行结束!\n")])])]),t("ul",[t("li",[a._v("非阻塞代码实例\n把 app.js 文件改成：")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('var fs = require("fs");\nfs.readFile(\'input.txt\', function (err, data) {\n    if (err) return console.error(err);\n    console.log(data.toString());\n});\nconsole.log("程序执行结束!");\n')])])]),t("p",[a._v("以上代码执行结果如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("$ node app.js\n程序执行结束!\n易编网--最好的JS全栈培训\n")])])]),t("p",[a._v("以上两个实例我们了解了阻塞与非阻塞调用的不同。")]),a._v(" "),t("p",[a._v("第一个实例在文件读取完后才执行程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。")]),a._v(" "),t("p",[a._v("因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。")]),a._v(" "),t("h3",{attrs:{id:"_3-3-node-js-事件循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-node-js-事件循环"}},[a._v("#")]),a._v(" 3.3 Node.js 事件循环")]),a._v(" "),t("ul",[t("li",[a._v("Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。")]),a._v(" "),t("li",[a._v("Node.js 几乎每一个 API 都是支持回调函数的,Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。")]),a._v(" "),t("li",[a._v("Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.")])]),a._v(" "),t("p",[a._v("Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。")]),a._v(" "),t("p",[a._v("这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。")]),a._v(" "),t("p",[a._v("Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var events = require('events');\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();\n")])])]),t("p",[a._v("以下程序绑定事件处理程序：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 绑定事件及事件的处理程序\neventEmitter.on('eventName', eventHandler);\n")])])]),t("p",[a._v("我们可以通过程序触发事件：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 触发事件\neventEmitter.emit('eventName');\n")])])]),t("p",[a._v("把 app.js 文件改成：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var events = require('events');\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();\n// 创建事件处理程序\nvar connectHandler = function connected() {\n   console.log('连接成功。');\n  \n   // 触发 data_received 事件 \n   eventEmitter.emit('data_received');\n}\n// 绑定 connection 事件处理程序\neventEmitter.on('connection', connectHandler);\n// 使用匿名函数绑定 data_received 事件\neventEmitter.on('data_received', function(){\n   console.log('数据接收成功。');\n});\n// 触发 connection 事件 \neventEmitter.emit('connection');\nconsole.log(\"程序执行完毕。\");\n")])])]),t("p",[a._v("接下来让我们执行以上代码：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("$ node app.js\n连接成功。\n数据接收成功。\n程序执行完毕。\n")])])]),t("p",[a._v("在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。")]),a._v(" "),t("p",[a._v("接下来让我们来重新看下前面的实例，fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。")]),a._v(" "),t("h3",{attrs:{id:"_3-4-node-js模块系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-node-js模块系统"}},[a._v("#")]),a._v(" 3.4 Node.js模块系统")]),a._v(" "),t("p",[a._v("为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。")]),a._v(" "),t("p",[a._v("模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。")]),a._v(" "),t("p",[a._v("在 Node.js 中，创建一个模块非常简单，如下我们创建一个 main.js 文件，代码如下:")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var hello = require('./hello');\nhello.world();\n以上实例中，代码 require('./hello') 引入了当前目录下的 hello.js 文件（./ 为当前目录，node.js 默认后缀为 js）。\n")])])]),t("p",[a._v("Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。")]),a._v(" "),t("p",[a._v("接下来我们就来创建 hello.js 文件，代码如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("exports.world = function() {\n  console.log('Hello World');\n}\n")])])]),t("p",[a._v("在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require('./hello') 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。")]),a._v(" "),t("p",[a._v("有时候我们只是想把一个对象封装到模块中，格式如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("module.exports = function() {\n  // ...\n}\n")])])]),t("p",[a._v("例如:")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("//hello.js \nfunction Hello() { \n    var name; \n    this.setName = function(thyName) { \n        name = thyName; \n    }; \n    this.sayHello = function() { \n        console.log('Hello ' + name); \n    }; \n}; \nmodule.exports = Hello;\n")])])]),t("p",[a._v("这样就可以直接获得这个对象了：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("//main.js \nvar Hello = require('./hello'); \nhello = new Hello(); \nhello.setName('BYVoid'); \nhello.sayHello(); \n")])])]),t("p",[a._v("模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。")]),a._v(" "),t("h3",{attrs:{id:"_3-5-node-js-函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-node-js-函数"}},[a._v("#")]),a._v(" 3.5 Node.js 函数")]),a._v(" "),t("p",[a._v("在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。")]),a._v(" "),t("p",[a._v("Node.js中函数的使用与Javascript类似，举例来说，你可以这样做：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('function say(word) {\n  console.log(word);\n}\n\nfunction execute(someFunction, value) {\n  someFunction(value);\n}\n\nexecute(say, "Hello");\n')])])]),t("p",[a._v("以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！")]),a._v(" "),t("p",[a._v("这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。")]),a._v(" "),t("p",[a._v("当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量.")]),a._v(" "),t("h3",{attrs:{id:"_3-6-node-js-全局对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-node-js-全局对象"}},[a._v("#")]),a._v(" 3.6 Node.js 全局对象")]),a._v(" "),t("p",[a._v("JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。")]),a._v(" "),t("p",[a._v("在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。")]),a._v(" "),t("p",[a._v("在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。")]),a._v(" "),t("p",[a._v("global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：")]),a._v(" "),t("ul",[t("li",[a._v("在最外层定义的变量；")]),a._v(" "),t("li",[a._v("全局对象的属性；")]),a._v(" "),t("li",[a._v("隐式定义的变量（未定义直接赋值的变量）。")])]),a._v(" "),t("p",[a._v("当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。")]),a._v(" "),t("p",[a._v("注意： 最好不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。")]),a._v(" "),t("h2",{attrs:{id:"_04-使用-koa-框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_04-使用-koa-框架"}},[a._v("#")]),a._v(" 04 使用 koa 框架")]),a._v(" "),t("h3",{attrs:{id:"_4-1-使用原生nodejs提供web服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-使用原生nodejs提供web服务"}},[a._v("#")]),a._v(" 4.1 使用原生nodejs提供web服务")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const http = require('http');\nhttp.createServer((req, res) => {\n  res.writeHead(200,{'Content-Type': 'application/json;charset=utf-8;'});\n  res.write('{text: \"写代码很快乐啊!\"}');\n  res.end();\n}).listen(8888)；\n")])])]),t("p",[a._v("可以看到，代码可读性不是很好，开发也不是很便利，于是就有了 Express 这个第一代最流行的web框架。")]),a._v(" "),t("h3",{attrs:{id:"_4-2-我们看看，使用express，-怎么实现一个最简单的入门网站："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-我们看看，使用express，-怎么实现一个最简单的入门网站："}},[a._v("#")]),a._v(" 4.2 我们看看，使用express， 怎么实现一个最简单的入门网站：")]),a._v(" "),t("p",[a._v("我们看看，使用express， 怎么实现一个最简单的入门网站：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var express = require('express');\nvar app = express();\napp.get('/', function (req, res) {\n    res.send('写代码很快乐!');\n});\napp.listen(8888);\n")])])]),t("p",[a._v("可以看到，代码精简了很多，虽然express的API很简单，但是它是基于ES5的语法，要实现异步代码，只有一个方法：回调。如果异步嵌套层次过多，代码写起来就非常难看，比如读取一个文件成功后再读取一个文件：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("app.get('/file', function (req, res) {\n    fs.readFile('/file1', function (err, data) {\n        if (err) { res.status(500).send('读取文件1失败'); }\n        fs.readFile('/file2', function (err, data) {\n            if (err) {  res.status(500).send('读取文件2失败'); }\n            res.type('text/plain');\n            res.send(data);\n        });\n    });\n});\n")])])]),t("p",[a._v("虽然可以用async这样的库来组织异步代码，但是用回调写异步实在是太痛苦了，特别是异步嵌套多的时候，这就是JS远古时期的 回调地狱！")]),a._v(" "),t("h3",{attrs:{id:"_4-3-koa-1-x的到来"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-koa-1-x的到来"}},[a._v("#")]),a._v(" 4.3 koa 1.x的到来")]),a._v(" "),t("p",[a._v("随着ES6在新版Node.js获得支持ES6，express的团队基于ES6的generator推出了koa这个 web 框架。和express相比，koa 1.0使用generator实现异步，比如实现上面同样的功能，代码如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var koa = require('koa');\nvar app = koa();\n\napp.use('/file', function *() {\n    yield readFile1();\n    var data = yield readFile2();\n    this.body = data;\n});\napp.listen(8888);\n")])])]),t("p",[a._v("可以看到，用generator实现异步比回调简单了不少，但是generator的本意并不是异步。Promise才是为异步设计的，但是Promise的写法很复杂。为了简化异步代码，ES7引入了新的关键字async和await，可以轻松地把一个function变为异步模式：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("async function () {\n    var data = await fs.read('/file1');\n}\n")])])]),t("h3",{attrs:{id:"_4-4-最新的koa-2-x的到来"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-最新的koa-2-x的到来"}},[a._v("#")]),a._v(" 4.4 最新的koa 2.x的到来")]),a._v(" "),t("p",[a._v("koa团队并没有止步于koa 1.0，他们非常超前地基于ES7开发了koa2，和koa 1相比，koa2完全使用Promise并配合async来实现异步。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("app.use(async (ctx, next) => {\n    await next();\n    var data = await readFile();\n    ctx.response.type = 'text/plain';\n    ctx.response.body = data;\n});\n")])])]),t("p",[a._v("通过以上分享，大家可以看到，我们项目使用koa2，是按照node->express->koa1-<koa2 一步步随着新的JS规范通过并获得支持的发展而来的，出现的主要原因就是为了在node开发中优雅的写异步代码。")]),a._v(" "),t("h3",{attrs:{id:"_4-5-express-koa1和koa2的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-express-koa1和koa2的区别"}},[a._v("#")]),a._v(" 4.5 express, koa1和koa2的区别")]),a._v(" "),t("h4",{attrs:{id:"koa-vs-express"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#koa-vs-express"}},[a._v("#")]),a._v(" koa vs express")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("相同点")]),a._v(" "),t("ul",[t("li",[a._v("构建 web 应用的 node 框架")]),a._v(" "),t("li",[a._v("总体来看语法差别不大，比如都是引入后框架后实例后，中间件处理以及监听端口；")]),a._v(" "),t("li",[a._v("都是同一个团队开发维护的")])])]),a._v(" "),t("li",[t("p",[a._v("区别")]),a._v(" "),t("ul",[t("li",[a._v("express: 框架内容更丰富，有更大的社区，历史更悠久，文档更丰富，用户群更大，支持 jade 等前端模板语言，express没有统一的错误处理，而koa有默认的错误处理方式。")]),a._v(" "),t("li",[a._v("koa: 更小、更富有表现力、更健壮，"),t("em",[t("strong",[a._v("Koa 支持 es6 语法")])]),a._v("，Koa 在内核方法中不绑定任何中间件，不提供路由功能和某些工具，摒弃了的回调，采用 generator 或 promise的方式，在 Context中，Koa 对 request 和 response 进行了封装，使用方式也相应改变，如返回简单内容，在koa: this.body = ‘hello world’，而在express: res.send(‘hello world’)。")])])])]),a._v(" "),t("h4",{attrs:{id:"koa1-vs-koa2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#koa1-vs-koa2"}},[a._v("#")]),a._v(" koa1 vs koa2")]),a._v(" "),t("ul",[t("li",[a._v("中间件的使用:  koa1依赖 co 并采用 generator 函数，在函数内使用 yield 语句，而koa2增加了箭头函数，移除了 co 依赖，使用 Promise，因此可以结合 async，await 使用；")]),a._v(" "),t("li",[a._v("context 对象的获取：koa1为this 对象，this.req, this.res；koa2: cxt 参数，cxt.req, cxt.res。")])]),a._v(" "),t("h3",{attrs:{id:"_4-6-koa相关的库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-koa相关的库"}},[a._v("#")]),a._v(" 4.6 koa相关的库")]),a._v(" "),t("p",[a._v("Koa为了保持自身的简洁，并没有捆绑中间件，但是在实际的开发中，我们需要和形形色色的中间件打交道。")]),a._v(" "),t("ul",[t("li",[a._v("路由中间件--koa-router：源码只有两个文件：router.js和layer.js，分别对应Router对象和Layer对象，Layer对象是对单个路由的管理，其中包含的信息有路由路径(path)、路由请求方法(method)和路由执行函数(middleware)，并且提供路由的验证以及params参数解析的方法。 相比较Layer对象，Router对象则是对所有注册路由的统一处理，并且它的API是面向开发者的。")]),a._v(" "),t("li",[a._v("请求报文的处理中间件--koa-bodyparser: koa.js并没有内置Request Body的解析器，当我们需要解析请求体时需要加载额外的中间件，官方提供的koa-bodyparser是个很不错的选择，支持x-www-form-urlencoded, application/json等格式的请求体，但不支持form-data的请求体，需要借助 formidable 这个库，也可以直接使用 koa-body 或 koa-better-body")]),a._v(" "),t("li",[a._v("koa-static: Node.js除了处理动态请求，也可以用作类似Nginx的静态文件服务，在本地开发时特别方便，可用于加载前端文件或后端Fake数据，可结合 koa-compress 和 koa-mount 使用。")]),a._v(" "),t("li",[a._v("koa-jwt\n随着网站前后端分离方案的流行，越来越多的网站从Session Base转为使用Token Base，JWT(Json Web Tokens)作为一个开放的标准被很多网站采用，koa-jwt这个中间件使用JWT认证HTTP请求。")]),a._v(" "),t("li",[a._v("koa-logger: 提供了输出请求日志的功能，包括请求的url、状态码、响应时间、响应体大小等信息，对于调试和跟踪应用程序特别有帮助，koa-bunyan-logger 提供了更丰富的功能。")]),a._v(" "),t("li",[a._v("koa-json: 解析JSON, 让 Koa2 支持响应 JSON 数据.")])]),a._v(" "),t("h2",{attrs:{id:"_05-使用mysql数据库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_05-使用mysql数据库"}},[a._v("#")]),a._v(" 05 使用MySQL数据库")]),a._v(" "),t("p",[a._v("MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(关系数据库管理系统)应用软件之一。")]),a._v(" "),t("h3",{attrs:{id:"_5-1-什么是数据库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-什么是数据库"}},[a._v("#")]),a._v(" 5.1 什么是数据库")]),a._v(" "),t("p",[a._v("数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。")]),a._v(" "),t("p",[a._v("我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理大数据量。")]),a._v(" "),t("p",[a._v("所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。")]),a._v(" "),t("h3",{attrs:{id:"_5-2-mysql数据库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-mysql数据库"}},[a._v("#")]),a._v(" 5.2 MySQL数据库")]),a._v(" "),t("p",[a._v("MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。")]),a._v(" "),t("p",[a._v("所有平台的 MySQL 下载地址为： https://dev.mysql.com/downloads/mysql/。 挑选你需要的 MySQL Community Server 版本及对应的平台。")]),a._v(" "),t("p",[a._v('权限设置： chown mysql:mysql -R /var/lib/mysql\n初始化 MySQL： mysqld --initialize\n启动 MySQL： systemctl start mysqld\n查看 MySQL 运行状态：systemctl status mysqld\n创建root用户的密码：mysqladmin -u root password "new_password"\n连接到Mysql服务器：mysql -u root -p\n检查MySQL服务器是否启动：ps -ef | grep mysqld')]),a._v(" "),t("p",[a._v("管理MySQL的命令:")]),a._v(" "),t("ul",[t("li",[a._v("使用 create 命令创建数据库: CREATE DATABASE 数据库名;")]),a._v(" "),t("li",[a._v("drop 命令删除数据库: drop database <数据库名>;")]),a._v(" "),t("li",[a._v("USE 数据库名:选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。")]),a._v(" "),t("li",[a._v("SHOW DATABASES: 列出 MySQL 数据库管理系统的数据库列表。")]),a._v(" "),t("li",[a._v("SHOW TABLES: 显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。")]),a._v(" "),t("li",[a._v("SHOW COLUMNS FROM 数据表: 显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。")])]),a._v(" "),t("h3",{attrs:{id:"_5-3-常用sql语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-常用sql语句"}},[a._v("#")]),a._v(" 5.3 常用SQL语句")]),a._v(" "),t("p",[a._v("创建MySQL数据表的SQL通用语法：CREATE TABLE table_name (column_name column_type);")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("CREATE TABLE IF NOT EXISTS `runoob_tbl`(\n   `runoob_id` INT UNSIGNED AUTO_INCREMENT,\n   `runoob_title` VARCHAR(100) NOT NULL,\n   `runoob_author` VARCHAR(40) NOT NULL,\n   `submission_date` DATE,\n   PRIMARY KEY ( `runoob_id` )\n)ENGINE=InnoDB DEFAULT CHARSET=utf8;\n")])])]),t("p",[a._v("实例解析：")]),a._v(" "),t("ul",[t("li",[a._v("如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。")]),a._v(" "),t("li",[a._v("AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。")]),a._v(" "),t("li",[a._v("PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。")]),a._v(" "),t("li",[a._v("ENGINE 设置存储引擎，CHARSET 设置编码。")])]),a._v(" "),t("p",[a._v("删除MySQL数据表的通用语法：DROP TABLE table_name;")]),a._v(" "),t("p",[a._v("向MySQL数据表插入数据通用的 INSERT INTO SQL语法：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN );\n")])])]),t("p",[a._v("在MySQL数据库中查询数据通用的 SELECT 语法：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("SELECT column_name,column_name\nFROM table_name\n[WHERE Clause]\n[LIMIT N][ OFFSET M]\n")])])]),t("p",[a._v("查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。")]),a._v(" "),t("ul",[t("li",[a._v("SELECT 命令可以读取一条或者多条记录。")]),a._v(" "),t("li",[a._v("你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据")]),a._v(" "),t("li",[a._v("你可以使用 WHERE 语句来包含任何条件。")]),a._v(" "),t("li",[a._v("你可以使用 LIMIT 属性来设定返回的记录数。")]),a._v(" "),t("li",[a._v("你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。")])]),a._v(" "),t("h3",{attrs:{id:"_5-4-orm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-orm"}},[a._v("#")]),a._v(" 5.4 ORM")]),a._v(" "),t("p",[a._v("对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。")]),a._v(" "),t("p",[a._v("简单的讲就是对SQL查询语句的封装，让我们可以用OOP的方式操作数据库，优雅的生成安全、可维护的SQL代码。直观上，是一种Model和SQL的映射关系。")]),a._v(" "),t("p",[a._v("ORM 使用对象，封装了数据库操作，因此可以不碰 SQL 语言。开发者只使用面向对象编程，与数据对象直接交互，不用关心底层数据库。")]),a._v(" "),t("p",[a._v("总结起来，ORM 有下面这些优点。")]),a._v(" "),t("ul",[t("li",[a._v("数据模型都在一个地方定义，更容易更新和维护，也利于重用代码。")]),a._v(" "),t("li",[a._v("ORM 有现成的工具，很多功能都可以自动完成，比如数据消毒、预处理、事务等等。")]),a._v(" "),t("li",[a._v("它迫使你使用 MVC 架构，ORM 就是天然的 Model，最终使代码更清晰。")]),a._v(" "),t("li",[a._v("基于 ORM 的业务代码比较简单，代码量少，语义性好，容易理解。")]),a._v(" "),t("li",[a._v("你不必编写性能不佳的 SQL。")])]),a._v(" "),t("p",[a._v("但是，ORM 也有很突出的缺点。")]),a._v(" "),t("ul",[t("li",[a._v("ORM 库不是轻量级工具，需要花很多精力学习和设置。")]),a._v(" "),t("li",[a._v("对于复杂的查询，ORM 要么是无法表达，要么是性能不如原生的 SQL。")]),a._v(" "),t("li",[a._v("ORM 抽象掉了数据库层，开发者无法了解底层的数据库操作，也无法定制一些特殊的 SQL。")])]),a._v(" "),t("h3",{attrs:{id:"_5-5-sequelize"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-sequelize"}},[a._v("#")]),a._v(" 5.5 Sequelize")]),a._v(" "),t("p",[a._v("Sequelize是一款基于Nodejs功能强大的异步ORM框架，通过映射数据库条目到对象，或者对象到数据库条目.")]),a._v(" "),t("p",[a._v("同时支持PostgreSQL, MySQL, SQLite and MSSQL多种数据库，很适合作为Nodejs后端数据库的存储接口，为快速开发Nodejs应用奠定扎实、安全的基础。")]),a._v(" "),t("p",[a._v("详情请访问官网：https://sequelize.org/")]),a._v(" "),t("h2",{attrs:{id:"_06-上线部署"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_06-上线部署"}},[a._v("#")]),a._v(" 06 上线部署")]),a._v(" "),t("p",[a._v("如果我们想让网站能够在任何连接互联网的地方，通过域名就能访问我们开发的网站，需要申请域名，购买服务器，去网管局备案，并且需要把网站部署到服务器。")]),a._v(" "),t("h3",{attrs:{id:"_6-1-浅谈部署"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-浅谈部署"}},[a._v("#")]),a._v(" 6.1 浅谈部署")]),a._v(" "),t("p",[a._v("域名申请一般需要去DNS服务商，推荐去阿里云注册一个账号，登录成功后找到域名注册入口即可。")]),a._v(" "),t("p",[a._v("服务器有物理服务器或者虚拟的云服务器，除非公司很大，一般我们都购买云服务器，亚马逊云、阿里云、腾讯云、华为云等，笔者比较熟悉的是阿里云，注册成功后，找到购买入口购买即可，可以从最低配置开始，随时可以升降级。")]),a._v(" "),t("p",[a._v("一般，购买大陆境内的服务器都需要到网管局备案，使用阿里云的整套方案的话比较方面，购买域名云服务器后，找到备案入口，按照文档说明进行操作和准备有关材料即可！")]),a._v(" "),t("p",[a._v("服务器市场产品繁多、功能和性能定位不一，由于厂商的服务器技术水平有所差别，在服务器可靠性、稳定性和可服务性上也存在某些程度上的不同。")]),a._v(" "),t("p",[a._v("服务器的选型也一个比较大的话题，大的将有物理服务器和近几年兴起的云服务器。从功能上又可分为Web服务器，文件服务器、邮件服务器、数据库服务器和多媒体服务器等。\n而服务器上的操作系统可以分为windows和linux系列服务器等。")]),a._v(" "),t("p",[a._v("多数服务器都是使用linux系统，而Linux系统又分为开源的Ubuntu系列、centos系统等，个人建站多用前者，而笔者所任职过的公司都用的是centos。")]),a._v(" "),t("p",[a._v("本文分享的是基于阿里云配置操作系统为centos7.x服务器的部署，而且是基于pm2部署node服务，仅作参考。")]),a._v(" "),t("h3",{attrs:{id:"_6-2-使用pm2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-使用pm2"}},[a._v("#")]),a._v(" 6.2 使用pm2")]),a._v(" "),t("p",[a._v("开发时，我们需要npm run …来启动一个node项目，如果终端被关掉，程序跟着停止，特别是启动多个项目时，多有不便，特别是部署到线上的时候，如果报错了可能直接终止整个运行，supervisor或nodemon一般只用在开发环境的。")]),a._v(" "),t("p",[a._v("而线上我们一般使用PM2，它是带有负载均衡功能的node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等。")]),a._v(" "),t("p",[a._v("打开我们本地的终端，输入如下命令登录远程服务器：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("ssh 用户名@云服务器IP地址\n// 例子 ssh root@173.123.34.55\n")])])]),t("p",[a._v("之后输入密码，登录成功后输入下面命令，-g是安装到全局(若提示npm命令不存在，则需要安装node或是环境配置有问题)：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm i\n")])])]),t("p",[a._v("常用命令：")]),a._v(" "),t("ul",[t("li",[a._v("启动:  pm2 start app.js")]),a._v(" "),t("li",[a._v("停止：pm2 stop app_name|app_id")]),a._v(" "),t("li",[a._v("停止所有：pm2 stop all")]),a._v(" "),t("li",[a._v("重启：pm2 restart app_name|app_id")]),a._v(" "),t("li",[a._v("删除：pm2 delete app_name|app_id")]),a._v(" "),t("li",[a._v("查看某一个进程的信息：pm2 describe app_name|app_id")]),a._v(" "),t("li",[a._v("查看所有的进程：pm2 list")]),a._v(" "),t("li",[a._v("查看所有的进程状态：pm2 status")])]),a._v(" "),t("p",[a._v("为项目配置启动脚本, 在package.json文件中加入启动脚本")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('  "scripts": {\n    "start": "nodemon app",\n    "deploy": "pm2 start app.js", // 新加脚本\n    "test": "echo \\"Error: no test specified\\" && exit 1"\n  },\n')])])]),t("p",[a._v("然后我们在项目目录下直接运行如下命令就可以了：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm run deploy\n")])])]),t("p",[a._v("可以采取多种方式，常用的是通过代码管理平台，如github或企业内部的gitlab，最简单的就是执行如下命令：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("scp 用户名@云服务器IP地址:\n// 例子 scp root@173.123.34.55:\n")])])]),t("p",[a._v("注意后面的冒号不能少哦，上传成功后，登录服务器后进入用户主目录，就能看到该文件，一般上传前我们会压缩，上传成功后再解压，解压以后在根目录下输入前面类似的部署命令即可：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm install && npm run deploy\n")])])]),t("p",[a._v("下安装项目依赖，成功后使用pm2启动node服务，这样一个静态网站就可以通过阿里云服务器IP地址加端口访问了。")]),a._v(" "),t("p",[a._v("而要想通过域名访问，就得去购买一个域名并且去网管局备案。")]),a._v(" "),t("h3",{attrs:{id:"_6-4-配置自动部署"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-配置自动部署"}},[a._v("#")]),a._v(" 6.4 配置自动部署")]),a._v(" "),t("p",[a._v("配置服务器免密登陆，将本地Mac生成的公钥 添加到远程服务器")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("ssh-keygen\nssh-copy-id -i .ssh/id_rsa.pub 用户名@47.92.xx.xxx\n")])])]),t("p",[a._v("初始化配置文件")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("pm2 ecosytem\n")])])]),t("p",[a._v("记得改成json格式，后端参考的例子如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  apps : [\n    {\n      name: "server",\n      script: "src/app.js",\n      env: {\n        COMMON_VARIABLE: "true"\n      },\n      env_production : {\n        NODE_ENV: "production"\n      }\n    }\n  ],\n  deploy : {\n    production : {\n      user: "xqart",\n      host: "47.xx.xxx.xxx",\n      ref: "origin/master",\n      repo: "git@github.com:yibiankeji/js-server-koa.git ",\n      path: "/home/study/server",\n      "post-deploy": "git pull && npm install && pm2 start ecosystem.json production"\n    }\n  }\n}\n')])])]),t("p",[a._v("初始化\b远程服务器")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("pm2 deploy production setup\n")])])]),t("p",[a._v("在两个项目下分别执行：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("pm2 deploy production\n")])])]),t("p",[a._v("然后就可以在本地电脑一键部署到远程云服务器了！")]),a._v(" "),t("h3",{attrs:{id:"_6-5-基于ngnix部署"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-基于ngnix部署"}},[a._v("#")]),a._v(" 6.5 基于ngnix部署")]),a._v(" "),t("p",[a._v("Nginx是一款2004年由俄罗斯的Igor Sysoev使用C语言开发的开发高性能的 Web和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器。在高连接并发的情况下，Nginx是Apache服务器不错的替代品。")]),a._v(" "),t("p",[a._v("Apache的发展时期很长，而且是毫无争议的世界第一大服务器。它有着很多优点：稳定、开源、跨平台等等。但它出现的时间太长了，它兴起的年代，互联网产业远远比不上现在。")]),a._v(" "),t("p",[a._v("所以它被设计为一个重量级的，不支持高并发的服务器。在Apache上运行数以万计的并发访问，会导致服务器消耗大量内存，导致HTTP请求的平均响应速度降低，决定了Apache不可能成为高性能WEB服务器。")]),a._v(" "),t("p",[a._v("安装ngnix")]),a._v(" "),t("ul",[t("li",[a._v("nginx编译依赖gcc环境")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("yum install gcc-c++\n")])])]),t("ul",[t("li",[a._v("安装pcre，nginx的http模块使用pcre来解析正则表达式.")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("yum install -y pcre pcre-devel\n")])])]),t("ul",[t("li",[a._v("安装zlib，nginx使用zlib对http包的内容进行gzip进行压缩和解压缩：")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("yum install -y zlib zlib-devel\n")])])]),t("ul",[t("li",[a._v("openssl，一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用，nginx不仅支持http协议，还支持https（即在ssl协议上传输http）：.")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("yum install -y openssl openssl-devel\n")])])]),t("ul",[t("li",[a._v("下载nginx源码包")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("wget http://nginx.org/download/nginx-1.12.0.tar.gz\n")])])]),t("ul",[t("li",[a._v("解压")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("tar -zxvf nginx-1.12.2.tar.gz\n\ncd nginx-1.12.0\n")])])]),t("ul",[t("li",[a._v("配置编译参数(可以使用./configure --help查询详细参数)")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("./configure \\\n--prefix=/usr/local/nginx \\\n--pid-path=/var/run/nginx/nginx.pid \\\n--lock-path=/var/lock/nginx.lock \\\n--error-log-path=/var/log/nginx/error.log \\\n--http-log-path=/var/log/nginx/access.log \\\n--with-http_gzip_static_module \\\n--http-client-body-temp-path=/var/temp/nginx/client \\\n--http-proxy-temp-path=/var/temp/nginx/proxy \\\n--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\\n--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\\n--http-scgi-temp-path=/var/temp/nginx/scgi\n")])])]),t("p",[a._v("注：安装之前需要手动创建上面指定的nginx文件夹，即/var/temp、/var/temp/nginx、/var/run/nginx/文件夹，否则启动时报错。")]),a._v(" "),t("ul",[t("li",[a._v("编译并安装")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("make && make install\n")])])]),t("p",[a._v("可以进入/usr/local/nginx查看文件是否存在conf、sbin、html文件夹，若存在则安装成功。")]),a._v(" "),t("ul",[t("li",[a._v("nginx命令全局执行设置")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("cd /usr/local/nginx/sbin/\nln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx\n")])])]),t("p",[a._v("ngnix常用命令")]),a._v(" "),t("ul",[t("li",[a._v("查看nginx版本")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("nginx  -v\n")])])]),t("ul",[t("li",[a._v("启动(一般都需要root权限，所以需要加sudo)")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("sudo nginx\n")])])]),t("ul",[t("li",[a._v("停止")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("nginx -s stop\nnginx -s quit\n")])])]),t("ul",[t("li",[a._v("动态加载")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("nginx -s reload\n")])])]),t("ul",[t("li",[a._v("测试配置文件nginx.conf正确性")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("nginx  -t\n")])])]),t("h2",{attrs:{id:"_07-使用ts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_07-使用ts"}},[a._v("#")]),a._v(" 07 使用TS")]),a._v(" "),t("h3",{attrs:{id:"_7-1-关于typescript"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-关于typescript"}},[a._v("#")]),a._v(" 7.1 关于typescript")]),a._v(" "),t("p",[a._v("ts并不神秘，虽然它出自微软之手，却不像IE浏览器那样，折腾得前端同学们伤不起，而是对Js生态的一个良好的补充。本质上，ts就是未来的js，ts不仅完全兼容js，并且会将一些主流还未支持的ECMA规范特性让我们提前用上，因为它最后还是需要转成js部署到线上。")]),a._v(" "),t("p",[a._v("从typescript的命名来看，其关键字是type，就是让js这一门动态语言，通过引入类型机制，在开发的时候享受静态语言的好处，让编程更规范且提前在编译阶段发现大量未知错误，让js可以像java, c++等语言一样具备开发大型复杂应用的能力。")]),a._v(" "),t("p",[a._v("目前世界上和国内主流互联网公司都有很多团队在大量使用ts, 微软不必说，google和facebook, 阿里腾讯等都可以看到他们有大量Js开发在使用Ts作为日常工作编程的语言。")]),a._v(" "),t("p",[a._v("同时，三大主流前端技术栈，react、vue、angular等核心库及其配置库，以及koa等node开发生态中的主流框架和库，都提供了对ts的支持，有的甚至直接就是使用ts从0开发的。")]),a._v(" "),t("p",[a._v("TypeScript能从可维护性、健壮性等方面提高代码质量。")]),a._v(" "),t("p",[a._v("因此，作为一名有追求的前端，不管是否有机会在工作中使用到ts，有时间的时候还是需要动动手，了解一下ts。")]),a._v(" "),t("h3",{attrs:{id:"_7-2-安装ts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-安装ts"}},[a._v("#")]),a._v(" 7.2 安装TS")]),a._v(" "),t("p",[a._v("需要有node环境，通过npm安装")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm install -g typescript\n")])])]),t("p",[a._v("使用tsc 命令可编译 .ts 文件， 生成一个同名 .js 文件；编译的时候即使报错了，还是会生成编译结果(.js)，可通过 tsconfig.json 文件配置.")]),a._v(" "),t("ul",[t("li",[a._v("入门教程： https://ts.xcatliu.com/")]),a._v(" "),t("li",[a._v("官网： https://devblogs.microsoft.com/typescript/")]),a._v(" "),t("li",[a._v("中文网：https://typescript.bootcss.com/")]),a._v(" "),t("li",[a._v("菜鸟教程：https://www.runoob.com/typescript/ts-tutorial.html")])]),a._v(" "),t("h3",{attrs:{id:"_7-3-配置ts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-配置ts"}},[a._v("#")]),a._v(" 7.3 配置TS")]),a._v(" "),t("p",[a._v("使用Typescript开发的好处:")]),a._v(" "),t("ul",[t("li",[a._v("较严格的类型检查和语法检查。")]),a._v(" "),t("li",[a._v("对ES6/ES2015/ES7(部分)支持比较好。")]),a._v(" "),t("li",[a._v("编译后的js文件很干净，也支持多种代码规范。")])]),a._v(" "),t("p",[a._v("typescript 生成 node 文件的配置需要生成配置文件 tsconfig.json")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("tsc --init\n")])])]),t("p",[a._v("sc会使用默认的编译配置编译目录中的所有.ts文件。通过书写tsconfig.json，我们可以配置tsc的编译行为，达到想要的结果.")]),a._v(" "),t("p",[a._v("模块的声明文件问题需要一个 node 包 @types/node")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm install @types/node --dev-save (--dev-save 安装在开发文件)\n")])])]),t("p",[a._v("对于内建模块，安装一个@types/node模块可以整体解决模块的声明文件问题。那么，对于浩如烟海的第三方模块，该怎么办呢？官方和社区中也提供了查找和安装的渠道。")]),a._v(" "),t("h3",{attrs:{id:"_7-3-开发时自动重启"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-开发时自动重启"}},[a._v("#")]),a._v(" 7.3 开发时自动重启")]),a._v(" "),t("p",[a._v("解决完了声明文件之后，其实我们已经可以使用ts简单的进行node.js项目的开发了。但是，每次写完或者修改代码，就要编译，然后再启动，是一件不大但是相当让人烦躁的事情。为了效率，我们应当改善它。")]),a._v(" "),t("p",[a._v('首先，要让.ts文件可以自动被编译。这在上文中的tsconfig.json文件中，已经被设置好了，就是"watch":true 。此时在命令行执行tsc命令后，编译器就会时时监控目录中.ts文件的变化，然后自动编译。')]),a._v(" "),t("p",[a._v("自动重启node服务器，我们可以使用 supervisor 模块解决，或者任何具有类似功能的解决方案都可以。")]),a._v(" "),t("p",[a._v("全局安装supervisor模块npm install -g supervisor，之后就可以在终端中使用supervior ./build/server.js启动服务器，并在服务器端代码改变之后，自动重启服务器。")]),a._v(" "),t("h2",{attrs:{id:"_08-模拟面试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_08-模拟面试"}},[a._v("#")]),a._v(" 08 模拟面试")]),a._v(" "),t("h3",{attrs:{id:"_8-1-为什么要用node"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-为什么要用node"}},[a._v("#")]),a._v(" 8.1 为什么要用node?")]),a._v(" "),t("ul",[t("li",[a._v("Node.js 是谷歌 V8 引擎（公认最快的 Javascript 解析引擎）、libuv平台抽象层（一个开源的、为 Node 定制而生的跨平台的异步 IO 库）以及主体使用 Javscript 编写的核心库三者集合的一个包装外壳；")]),a._v(" "),t("li",[a._v("一个使用事件驱动来实现异步开发的优秀解决方案，非阻塞IO, 能够处理庞大的并且高吞吐量的并发连接；")]),a._v(" "),t("li",[a._v("前后端使用统一编程语言，最佳地重用开发人员资源；")]),a._v(" "),t("li",[a._v("ES2015 发布后，发展很快，各大主流公司应用广泛，生态繁荣。")])]),a._v(" "),t("h3",{attrs:{id:"_8-2-谈谈-node-的适合场景？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-谈谈-node-的适合场景？"}},[a._v("#")]),a._v(" 8.2 谈谈 node 的适合场景？")]),a._v(" "),t("p",[a._v("NodeJS处理并发的能力强，但处理计算和逻辑的能力反而很弱，适合运用在高并发、I/O密集、少量业务逻辑的场景。因此，如果我们把复杂的逻辑运算都搬到前端（客户端）完成，而NodeJS只需要提供异步I/O，这样就可以实现对高并发的高性能处理。比如：RESTFUL API、实时聊天、客户端逻辑强大的单页APP。")]),a._v(" "),t("h3",{attrs:{id:"_8-3-谈谈-node的构架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-谈谈-node的构架"}},[a._v("#")]),a._v(" 8.3 谈谈 node的构架?")]),a._v(" "),t("p",[a._v("由 v8 、libuv, 内置模块、本地模块和其他辅助服务组成：")]),a._v(" "),t("ul",[t("li",[a._v("v8：虚拟机的功能，执行js代码和提供C++函数接口，为node提供v8初始化，创建context，scope等；")]),a._v(" "),t("li",[a._v("libuv：基于事件驱动的异步IO模型库，我们的js代码发出请求，最终由libuv完成，回调函数在libuv触发；")]),a._v(" "),t("li",[a._v("内置模块：由C++代码写成各类模块，包含了crypto，zlib, file stream等基础功能；")]),a._v(" "),t("li",[a._v("本地模块：由js写成，提供我们应用程序调用的库，同时这些模块又依赖内置模块来获取相应的服务支持；")])]),a._v(" "),t("h3",{attrs:{id:"_8-4-node中的事件循环是什么样子的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-node中的事件循环是什么样子的"}},[a._v("#")]),a._v(" 8.4 node中的事件循环是什么样子的?")]),a._v(" "),t("p",[a._v("event loop其实就是一个事件队列，先加入先执行，执行完一次队列，再次循环遍历看有没有新事件加入队列．执行中的叫IO events, setImmediate是在当前队列立即执行,setTimout/setInterval是把执行定时到下一个队列，process.nextTick是在当前执行完，下次遍历前执行．所以总体顺序是: IO events >> setImmediate >> setTimeout/setInterval >> process.nextTick。")]),a._v(" "),t("h3",{attrs:{id:"_8-5-读写一个文件有多少种方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-5-读写一个文件有多少种方法"}},[a._v("#")]),a._v(" 8.5 读写一个文件有多少种方法?")]),a._v(" "),t("ul",[t("li",[a._v("POSIX式底层读写")]),a._v(" "),t("li",[a._v("流式读写")]),a._v(" "),t("li",[a._v("同步文件读写")]),a._v(" "),t("li",[a._v("异步文件读写")])]),a._v(" "),t("h3",{attrs:{id:"_8-6-node是怎样支持https-tls的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-6-node是怎样支持https-tls的"}},[a._v("#")]),a._v(" 8.6 node是怎样支持https,tls的?")]),a._v(" "),t("ul",[t("li",[a._v("openssl生成公钥私钥")]),a._v(" "),t("li",[a._v("服务器或客户端使用https替代http")]),a._v(" "),t("li",[a._v("服务器或客户端加载公钥私钥证书")])]),a._v(" "),t("h3",{attrs:{id:"_8-7-怎样实现一个简单的http服务器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-7-怎样实现一个简单的http服务器"}},[a._v("#")]),a._v(" 8.7 怎样实现一个简单的http服务器?")]),a._v(" "),t("p",[a._v("三部曲：加载http模块，创建服务器，监听端口")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var http = require('http'); // 加载http模块\nhttp.createServer(function(req, res) {\n    res.writeHead(200, {'Content-Type': 'text/html'}); // 200代表状态成功, 文档类型是给浏览器识别用的\n    res.write('\n      <meta charset=\"UTF-8\">\n      <h1>欢迎使用nodejs</h1> \n    '); // 返回给客户端的html数据\n    res.end(); // 结束输出流\n}).listen(3000); // 绑定端口, 通过 http://localhost:3000 访问\n")])])]),t("h3",{attrs:{id:"_8-8-怎样绑定node程序到80端口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-8-怎样绑定node程序到80端口"}},[a._v("#")]),a._v(" 8.8 怎样绑定node程序到80端口?")]),a._v(" "),t("ul",[t("li",[a._v("sudo 启动，因为在类Unix系统中监听80端口需要超级用户权限，不推荐")]),a._v(" "),t("li",[a._v("apache/nginx代理")]),a._v(" "),t("li",[a._v("用操作系统的firewall iptables进行端口重定向")])]),a._v(" "),t("h3",{attrs:{id:"_8-9-如何避免回调地狱？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-9-如何避免回调地狱？"}},[a._v("#")]),a._v(" 8.9 如何避免回调地狱？")]),a._v(" "),t("ul",[t("li",[a._v("模块化：将回调函数转换为独立的函数")]),a._v(" "),t("li",[a._v("使用流程控制库，例如[aync]")]),a._v(" "),t("li",[a._v("使用Promise")]),a._v(" "),t("li",[a._v("使用async/await")])]),a._v(" "),t("h3",{attrs:{id:"_8-10-最喜欢node哪个http框架？为什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-10-最喜欢node哪个http框架？为什么？"}},[a._v("#")]),a._v(" 8.10 最喜欢node哪个HTTP框架？为什么？")]),a._v(" "),t("ul",[t("li",[a._v("提到Node.js开发，不得不提服务端的开发框架express和koa，都是对HTTP Request和HTTP Response两个对象的封装和处理，应用的生命周期维护以及视图的处理等。Express主要基于Connect中间件框架，功能丰富，随取随用，并且框架自身封装了大量便利的功能，比如路由、视图处理等等。而koa主要基于co中间件框架，框架自身并没集成太多功能，大部分功能需要用户自行require中间件去解决，但是由于其基于ES6 generator特性的中间件机制，解决了长期诟病的“callback hell”和麻烦的错误处理的问题，大受开发者欢迎。")]),a._v(" "),t("li",[a._v("而基于koa框架，则会考虑360的thinkjs或阿里的egg，因为egg用得多且只专注于提供 Web 开发的核心功能和一套灵活可扩展的插件机制，而不去集成如数据库、模板引擎、前端框架等功能，更适合在团队中使用。")])]),a._v(" "),t("h3",{attrs:{id:"_8-11-下列代码的输出结果？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-11-下列代码的输出结果？"}},[a._v("#")]),a._v(" 8.11 下列代码的输出结果？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var value1 = 0, value2 = 0, value3 = 0;\nfor ( var i = 1; i <= 3; i++) {\n    var i2 = i;\n    (function() {\n        var i3 = i;\n        setTimeout(function() {\n            value1 += i;\n            value2 += i2;\n            value3 += i3;\n        }, 1);\n    })();\n}\nsetTimeout(function() {\n    console.log(value1, value2, value3);\n}, 100);\n")])])]),t("p",[a._v("12 9 6")])])}),[],!1,null,null,null);e.default=v.exports}}]);