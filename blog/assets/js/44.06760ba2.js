(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{289:function(a,t,v){"use strict";v.r(t);var r=v(28),n=Object(r.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[a._v("#")]),a._v(" 函数")]),a._v(" "),v("p",[a._v("函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。")]),a._v(" "),v("p",[a._v("JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。")]),a._v(" "),v("h2",{attrs:{id:"函数的声明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数的声明"}},[a._v("#")]),a._v(" 函数的声明")]),a._v(" "),v("p",[a._v("JavaScript 有三种声明函数的方法。如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。")]),a._v(" "),v("h3",{attrs:{id:"function-命令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#function-命令"}},[a._v("#")]),a._v(" function 命令")]),a._v(" "),v("p",[a._v("function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面")]),a._v(" "),v("h3",{attrs:{id:"函数表达式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数表达式"}},[a._v("#")]),a._v(" 函数表达式")]),a._v(" "),v("p",[a._v("除了用function命令声明函数，还可以采用变量赋值的写法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var print = function(s) {\n  console.log(s);\n};\n")])])]),v("p",[a._v("这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。")]),a._v(" "),v("p",[a._v("采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。")]),a._v(" "),v("p",[a._v("加上函数名的写法用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。")]),a._v(" "),v("h3",{attrs:{id:"function-构造函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#function-构造函数"}},[a._v("#")]),a._v(" Function 构造函数")]),a._v(" "),v("p",[a._v("第三种声明函数的方式是Function构造函数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var add = new Function(\n  'x',\n  'y',\n  'return x + y'\n);\n")])])]),v("p",[a._v("可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。")]),a._v(" "),v("h2",{attrs:{id:"圆括号运算符，return-语句和递归"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#圆括号运算符，return-语句和递归"}},[a._v("#")]),a._v(" 圆括号运算符，return 语句和递归")]),a._v(" "),v("p",[a._v("调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。")]),a._v(" "),v("p",[a._v("函数体内部的return语句，表示返回。JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。")]),a._v(" "),v("p",[a._v("函数可以调用自身，这就是递归（recursion）。")]),a._v(" "),v("h2",{attrs:{id:"函数名的提升"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数名的提升"}},[a._v("#")]),a._v(" 函数名的提升")]),a._v(" "),v("p",[a._v("JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。")]),a._v(" "),v("p",[a._v("但是，如果采用赋值语句定义函数，JavaScript 就会报错。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("f();\nvar f = function (){};\n// TypeError: undefined is not a function\n")])])]),v("h2",{attrs:{id:"函数的属性和方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数的属性和方法"}},[a._v("#")]),a._v(" 函数的属性和方法")]),a._v(" "),v("h3",{attrs:{id:"name-属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#name-属性"}},[a._v("#")]),a._v(" name 属性")]),a._v(" "),v("p",[a._v("name属性的一个用处，就是获取参数函数的名字。")]),a._v(" "),v("p",[a._v("函数的name属性返回函数的名字，如果是通过变量赋值定义的函数，那么name属性返回变量名。")]),a._v(" "),v("p",[a._v("但如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。")]),a._v(" "),v("h3",{attrs:{id:"length-属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#length-属性"}},[a._v("#")]),a._v(" length 属性")]),a._v(" "),v("p",[a._v("函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。")]),a._v(" "),v("p",[a._v("length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）。")]),a._v(" "),v("h3",{attrs:{id:"tostring"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tostring"}},[a._v("#")]),a._v(" toString()")]),a._v(" "),v("p",[a._v("函数的toString方法返回一个字符串，内容是函数的源码。")]),a._v(" "),v("p",[a._v("对于那些原生的函数，toString()方法返回function (){[native code]}")]),a._v(" "),v("h2",{attrs:{id:"函数作用域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数作用域"}},[a._v("#")]),a._v(" 函数作用域")]),a._v(" "),v("p",[a._v("作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域。")]),a._v(" "),v("p",[a._v("对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。")]),a._v(" "),v("p",[a._v("在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。")]),a._v(" "),v("p",[a._v("函数内部定义的变量，会在该作用域内覆盖同名全局变量。")]),a._v(" "),v("p",[a._v("与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。")]),a._v(" "),v("p",[a._v("函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。")]),a._v(" "),v("h2",{attrs:{id:"参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参数"}},[a._v("#")]),a._v(" 参数")]),a._v(" "),v("p",[a._v("函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。")]),a._v(" "),v("p",[a._v("函数参数不是必需的，JavaScript 允许省略参数。函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。")]),a._v(" "),v("p",[a._v("没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。")]),a._v(" "),v("p",[a._v("数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。")]),a._v(" "),v("p",[a._v("但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。")]),a._v(" "),v("p",[a._v("如果有同名的参数，则取最后出现的那个值。")]),a._v(" "),v("h2",{attrs:{id:"arguments-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#arguments-对象"}},[a._v("#")]),a._v(" arguments 对象")]),a._v(" "),v("p",[a._v("由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。")]),a._v(" "),v("p",[a._v("arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。")]),a._v(" "),v("p",[a._v("严格模式下，arguments对象与函数参数不具有联动关系。也就是说，修改arguments对象不会影响到实际的函数参数。")]),a._v(" "),v("p",[a._v("arguments对象带有一个callee属性，返回它所对应的原函数。可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。")]),a._v(" "),v("h2",{attrs:{id:"闭包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[a._v("#")]),a._v(" 闭包")]),a._v(" "),v("p",[a._v("闭包可以看作是函数内部作用域的一个接口。闭包的另一个用处，是封装对象的私有属性和私有方法。")]),a._v(" "),v("p",[a._v("如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f1() {\n  var n = 999;\n  function f2() {\n    console.log(n);\n  }\n  return f2;\n}\n\nvar result = f1();\nresult();\n")])])]),v("p",[a._v('JavaScript 语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。')]),a._v(" "),v("p",[a._v("闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。")]),a._v(" "),v("p",[a._v("闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。")]),a._v(" "),v("p",[a._v("闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。")]),a._v(" "),v("p",[a._v("外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。")]),a._v(" "),v("h2",{attrs:{id:"立即调用的函数表达式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#立即调用的函数表达式"}},[a._v("#")]),a._v(" 立即调用的函数表达式")]),a._v(" "),v("p",[a._v("有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。")]),a._v(" "),v("p",[a._v("为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。")]),a._v(" "),v("p",[a._v("解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("(function(){ /* code */ }());\n// 或者\n(function(){ /* code */ })();\n")])])]),v("p",[a._v("上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。")]),a._v(" "),v("p",[a._v("通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。")])])}),[],!1,null,null,null);t.default=n.exports}}]);