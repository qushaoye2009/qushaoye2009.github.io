(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{310:function(e,t,a){"use strict";a.r(t);var s=a(28),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"_4-2-koa-源码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-koa-源码"}},[e._v("#")]),e._v(" 4_2 koa 源码")]),e._v(" "),a("p",[e._v("本节将带着大家简单看一下koa2.x最新版本的源码。")]),e._v(" "),a("h2",{attrs:{id:"源码结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源码结构"}},[e._v("#")]),e._v(" 源码结构")]),e._v(" "),a("p",[e._v("在上一章我们已经分享了查看依赖库源码的方法，本节我们还是基于方式一，直接到项目下de node_modules目录下找到koa。包含了如下文件：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("├── History.md // 历史版本管理\n├── LICENSE // 开源协议\n├── Readme.md // 依赖库的有关介绍\n├── lib\n│   ├── application.js //入口文件，封装了context，request，response，以及最核心的中间件处理流程。\n│   ├── context.js //处理应用上下文，里面直接封装部分request.js和response.js的方法\n│   ├── request.js // 处理http请求\n│   └── response.js // 处理http响应\n└── package.json // 模块管理\n")])])]),a("p",[e._v("我们看到源码都在lib目录下, koa2.x作为一个web框架，只提供了封装好的HTTP服务，以及基于async/await的中间件容器。用Koa.js想实现大部分Web功能的话，就需要通过中间件来实现，如我们前面用到的koa-static。")]),e._v(" "),a("h2",{attrs:{id:"一些常用方法的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一些常用方法的实现"}},[e._v("#")]),e._v(" 一些常用方法的实现")]),e._v(" "),a("ul",[a("li",[e._v("listen如何实现的？")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" listen(...args) {\n    debug('listen');\n    const server = http.createServer(this.callback());\n    return server.listen(...args);\n  }\n")])])]),a("ul",[a("li",[e._v("app.use() 干了啥？")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  use(fn) {\n    ...省略了各种异常和兼容处理\n    if (isGeneratorFunction(fn)) {\n      fn = convert(fn); \n      // koa@2中间件只支持 async/await 封装的，如果要使用koa@1基于generator中间件，需要通过中间件koa-convert封装一下才能使用\n    }\n    this.middleware.push(fn);\n    return this;\n  }\n")])])]),a("ul",[a("li",[e._v("callback 源码")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  callback() {\n    const fn = compose(this.middleware);\n    if (!this.listenerCount('error')) this.on('error', this.onerror);\n    const handleRequest = (req, res) => {\n      const ctx = this.createContext(req, res);\n      return this.handleRequest(ctx, fn);\n    };\n    return handleRequest;\n  }\n")])])]),a("p",[e._v("可以看到，在我们实例化 "),a("code",[e._v("const app = new koa();")]),e._v(" 后，执行 "),a("code",[e._v("app.use()")]),e._v(" 系列中间件后，会把各中间件添加进 middleware 这个数组，然后再执行"),a("code",[e._v("app.listen()")]),e._v(" 的时候，会把callback()回调函数传入 node原生的http模块的createServer()方法，然后在启动服务器以后就会执行callback()中请求、响应、上下文以及中间件的有关逻辑了。更深入的探究，就是基于此一步步分析各个模块的实现了。")])])}),[],!1,null,null,null);t.default=n.exports}}]);