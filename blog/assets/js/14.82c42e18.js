(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{260:function(a,t,_){"use strict";_.r(t);var s=_(28),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"七至九章"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#七至九章"}},[a._v("#")]),a._v(" 七至九章")]),a._v(" "),_("h2",{attrs:{id:"_7-1-如何理解函数声明提升？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-如何理解函数声明提升？"}},[a._v("#")]),a._v(" 7.1 如何理解函数声明提升？")]),a._v(" "),_("p",[a._v("执行代码之前会读取函数声明，这意味着可以把函数声明放在调用它语句的后面。")]),a._v(" "),_("h2",{attrs:{id:"_7-2-匿名函数的name属性是？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-匿名函数的name属性是？"}},[a._v("#")]),a._v(" 7.2 匿名函数的name属性是？")]),a._v(" "),_("p",[a._v("空字符串")]),a._v(" "),_("h2",{attrs:{id:"_7-3-怎样实现对函数的递归调用最安全？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-怎样实现对函数的递归调用最安全？"}},[a._v("#")]),a._v(" 7.3 怎样实现对函数的递归调用最安全？")]),a._v(" "),_("p",[a._v("最好使用命名函数表达式，因为使用函数声明时进行引用赋值时，一旦将原来的函数名设置为null，就会导致错误；而使用arguments.callee代替函数名进行递归调用，在严格模式会不允许。")]),a._v(" "),_("h2",{attrs:{id:"_7-4什么是闭包？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-4什么是闭包？"}},[a._v("#")]),a._v(" 7.4什么是闭包？")]),a._v(" "),_("p",[a._v("闭包是指有权访问另一个函数作用域中变量的函数。")]),a._v(" "),_("h2",{attrs:{id:"_7-5创建闭包的常见方式？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-5创建闭包的常见方式？"}},[a._v("#")]),a._v(" 7.5创建闭包的常见方式？")]),a._v(" "),_("p",[a._v("在一个函数内部创建另一个函数。")]),a._v(" "),_("h2",{attrs:{id:"_7-6函数第一次调用时发生了什么？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-6函数第一次调用时发生了什么？"}},[a._v("#")]),a._v(" 7.6函数第一次调用时发生了什么？")]),a._v(" "),_("p",[a._v("创建一个执行环境及相应的作用域链，并把作用域链赋值给一个特殊的内部属性[[scope]],然后使用this，arguments和其他命名参数值来初始化函数的活动对象。")]),a._v(" "),_("h2",{attrs:{id:"_7-7作用域链的本质是？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-7作用域链的本质是？"}},[a._v("#")]),a._v(" 7.7作用域链的本质是？")]),a._v(" "),_("p",[a._v("一个指向变量对象的指针列表，它只引用但不实际包含变量对象。")]),a._v(" "),_("h2",{attrs:{id:"_7-8为何建议只在绝对必要时在考虑闭包？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-8为何建议只在绝对必要时在考虑闭包？"}},[a._v("#")]),a._v(" 7.8为何建议只在绝对必要时在考虑闭包？")]),a._v(" "),_("p",[a._v("闭包换携带包含它的函数的作用域，因此会比其他函数占用更多的内存，过度使用闭包会导致内存占用过多。")]),a._v(" "),_("h2",{attrs:{id:"_7-9匿名函数的this指向？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-9匿名函数的this指向？"}},[a._v("#")]),a._v(" 7.9匿名函数的this指向？")]),a._v(" "),_("p",[a._v("Window，因为它的执行环具有全局性。")]),a._v(" "),_("h2",{attrs:{id:"_7-10函数被调用时，其活动对象自动获取的特殊变量有？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-10函数被调用时，其活动对象自动获取的特殊变量有？"}},[a._v("#")]),a._v(" 7.10函数被调用时，其活动对象自动获取的特殊变量有？")]),a._v(" "),_("p",[a._v("this和arguments。")]),a._v(" "),_("h2",{attrs:{id:"_7-11闭包的副作用有？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-11闭包的副作用有？"}},[a._v("#")]),a._v(" 7.11闭包的副作用有？")]),a._v(" "),_("p",[a._v("只能取得函数中任何变量的最后一个值；\nThis指向不符合预期；\n容易发生内存泄漏；")]),a._v(" "),_("h2",{attrs:{id:"_7-12如何看待重复声明变量？如何解决？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-12如何看待重复声明变量？如何解决？"}},[a._v("#")]),a._v(" 7.12如何看待重复声明变量？如何解决？")]),a._v(" "),_("p",[a._v("对后续声明视而不见，但会执行变量的初始化；模仿块级作用域。")]),a._v(" "),_("h2",{attrs:{id:"_7-13模仿块级作用域的技术一般用在哪？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-13模仿块级作用域的技术一般用在哪？"}},[a._v("#")]),a._v(" 7.13模仿块级作用域的技术一般用在哪？")]),a._v(" "),_("p",[a._v("全局作用域被用在函数外部，以限制向全局作用域中添加过多的变量和函数，从而避免命名冲突。")]),a._v(" "),_("h2",{attrs:{id:"_7-14什么是单例？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-14什么是单例？"}},[a._v("#")]),a._v(" 7.14什么是单例？")]),a._v(" "),_("p",[a._v("只有一个实例的对象")]),a._v(" "),_("h2",{attrs:{id:"_8-1bom的事实标准是？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-1bom的事实标准是？"}},[a._v("#")]),a._v(" 8.1BOM的事实标准是？")]),a._v(" "),_("p",[a._v("浏览器之间共有的对象")]),a._v(" "),_("h2",{attrs:{id:"_8-2window对象的双重角色是？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-2window对象的双重角色是？"}},[a._v("#")]),a._v(" 8.2window对象的双重角色是？")]),a._v(" "),_("p",[a._v("既是JS访问浏览器窗口的接口，又是ECMAScript规定的Global对象。")]),a._v(" "),_("h2",{attrs:{id:"_8-3定义全局变量与在window对象上直接定义属性的区别？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-3定义全局变量与在window对象上直接定义属性的区别？"}},[a._v("#")]),a._v(" 8.3定义全局变量与在window对象上直接定义属性的区别？")]),a._v(" "),_("p",[a._v("全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。")]),a._v(" "),_("h2",{attrs:{id:"_8-4引入self对象的目的是？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-4引入self对象的目的是？"}},[a._v("#")]),a._v(" 8.4引入self对象的目的是？")]),a._v(" "),_("p",[a._v("与top和parent对象对应起来。")]),a._v(" "),_("h2",{attrs:{id:"_8-5为何不建议给settimeout-方法第一个参数传递字符串？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-5为何不建议给settimeout-方法第一个参数传递字符串？"}},[a._v("#")]),a._v(" 8.5为何不建议给setTimeout()方法第一个参数传递字符串？")]),a._v(" "),_("p",[a._v("因为传递字符串可能导致性能损失。")]),a._v(" "),_("h2",{attrs:{id:"_8-6为何settimeout-经过第二个参设置的时间后不一定会执行？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-6为何settimeout-经过第二个参设置的时间后不一定会执行？"}},[a._v("#")]),a._v(" 8.6为何setTimeout()经过第二个参设置的时间后不一定会执行？")]),a._v(" "),_("p",[a._v("因为JS是一个单线程语言，一定时间内只能执行一段代码，如果任务队列为空，添加的代码会立即执行，若非空，就需要等前面的代码执行后再可执行。")]),a._v(" "),_("h2",{attrs:{id:"_8-7为何取消间歇调用比取消超时调用重要？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-7为何取消间歇调用比取消超时调用重要？"}},[a._v("#")]),a._v(" 8.7为何取消间歇调用比取消超时调用重要？")]),a._v(" "),_("p",[a._v("因为在不加干涉的情况下，间歇调用会一直执行下去")]),a._v(" "),_("h2",{attrs:{id:"_8-8为何location对象是bom最有用的对象之一？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-8为何location对象是bom最有用的对象之一？"}},[a._v("#")]),a._v(" 8.8为何location对象是BOM最有用的对象之一？")]),a._v(" "),_("p",[a._v("因为它提供了与当前窗口中加载文档的有关信息，还提供了一些导航功能。")]),a._v(" "),_("h2",{attrs:{id:"_8-9location对象有何特殊之处？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-9location对象有何特殊之处？"}},[a._v("#")]),a._v(" 8.9location对象有何特殊之处？")]),a._v(" "),_("p",[a._v("它既是window对象的属性，也是document对象的属性。")]),a._v(" "),_("h2",{attrs:{id:"_8-10为何要把reload-放在代码的最后一行？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-10为何要把reload-放在代码的最后一行？"}},[a._v("#")]),a._v(" 8.10为何要把reload()放在代码的最后一行？")]),a._v(" "),_("p",[a._v("因为位于reload()调用之后的代码可能会也可能不执行，这取决了网络延迟或系统资源等因素。")]),a._v(" "),_("h2",{attrs:{id:"_8-11bom的对象有？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-11bom的对象有？"}},[a._v("#")]),a._v(" 8.11BOM的对象有？")]),a._v(" "),_("p",[a._v("框架相关的top、parent、self对象\nlocation对象、navigator对象、screen对象和history对象。")]),a._v(" "),_("h2",{attrs:{id:"_9-1什么时候使用客户端检测？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-1什么时候使用客户端检测？"}},[a._v("#")]),a._v(" 9.1什么时候使用客户端检测？")]),a._v(" "),_("p",[a._v("找不到更通用的方法之后，万不得以")]),a._v(" "),_("h2",{attrs:{id:"_9-2能力检测的目标是？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-2能力检测的目标是？"}},[a._v("#")]),a._v(" 9.2能力检测的目标是？")]),a._v(" "),_("p",[a._v("不是识别浏览器，而是识别浏览器的能力。")]),a._v(" "),_("h2",{attrs:{id:"_9-3能力检测需要注意什么？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-3能力检测需要注意什么？"}},[a._v("#")]),a._v(" 9.3能力检测需要注意什么？")]),a._v(" "),_("p",[a._v("尽量使用typeof进行检测，该特性是否按照适当方式进行。")]),a._v(" "),_("h2",{attrs:{id:"_9-4在实际开发中，如何应用能力检测？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-4在实际开发中，如何应用能力检测？"}},[a._v("#")]),a._v(" 9.4在实际开发中，如何应用能力检测？")]),a._v(" "),_("p",[a._v("应该将能力检测作为确定下一步解决方案的依据，而不是用来判断用户使用的是什么浏览器。")]),a._v(" "),_("h2",{attrs:{id:"_9-5怪癖检测的目标是？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-5怪癖检测的目标是？"}},[a._v("#")]),a._v(" 9.5怪癖检测的目标是？")]),a._v(" "),_("p",[a._v("识别浏览器的特殊行为，存在什么缺陷。")]),a._v(" "),_("h2",{attrs:{id:"_9-6用户代理适用的情形有？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-6用户代理适用的情形有？"}},[a._v("#")]),a._v(" 9.6用户代理适用的情形有？")]),a._v(" "),_("p",[a._v("不能直接准确使用能力检测或怪癖检测；\n同一款浏览器在不同平台下具备不同的能力；\n为了跟踪分析等目的。")]),a._v(" "),_("h2",{attrs:{id:"_9-7客户端检测方法有？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-7客户端检测方法有？"}},[a._v("#")]),a._v(" 9.7客户端检测方法有？")]),a._v(" "),_("p",[a._v("能力检测、怪癖检测和用户代理检测。")])])}),[],!1,null,null,null);t.default=r.exports}}]);