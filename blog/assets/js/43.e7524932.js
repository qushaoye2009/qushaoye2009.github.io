(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{286:function(e,t,v){"use strict";v.r(t);var _=v(28),a=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"内置对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内置对象"}},[e._v("#")]),e._v(" 内置对象")]),e._v(" "),v("h2",{attrs:{id:"属性描述对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性描述对象"}},[e._v("#")]),e._v(" 属性描述对象")]),e._v(" "),v("p",[e._v("JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等。")]),e._v(" "),v("p",[e._v("这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。")]),e._v(" "),v("p",[e._v("Object.getOwnPropertyDescriptor()方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。")]),e._v(" "),v("p",[e._v("Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。")]),e._v(" "),v("p",[e._v("Object.defineProperty()方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象。")]),e._v(" "),v("p",[e._v("Object.defineProperty方法接受三个参数，依次如下。")]),e._v(" "),v("ul",[v("li",[e._v("object：属性所在的对象")]),e._v(" "),v("li",[e._v("propertyName：字符串，表示属性名")]),e._v(" "),v("li",[e._v("attributesObject：属性描述对象")])]),e._v(" "),v("p",[e._v("如果属性已经存在，Object.defineProperty()方法相当于更新该属性的属性描述对象。")]),e._v(" "),v("p",[e._v("如果一次性定义或修改多个属性，可以使用Object.defineProperties()方法。")]),e._v(" "),v("p",[e._v("如果一个属性的enumerable为false，下面三个操作不会取到该属性。")]),e._v(" "),v("ul",[v("li",[e._v("for..in循环")]),e._v(" "),v("li",[e._v("Object.keys方法")]),e._v(" "),v("li",[e._v("JSON.stringify方法")])]),e._v(" "),v("p",[e._v("for...in循环包括继承的属性，Object.keys方法不包括继承的属性。如果需要获取对象自身的所有属性，不管是否可遍历，可以使用Object.getOwnPropertyNames方法。")]),e._v(" "),v("p",[e._v("除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。")]),e._v(" "),v("p",[e._v("有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。")]),e._v(" "),v("h2",{attrs:{id:"object-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#object-对象"}},[e._v("#")]),e._v(" Object 对象")]),e._v(" "),v("p",[e._v("JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。")]),e._v(" "),v("p",[e._v("Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。")]),e._v(" "),v("p",[e._v("Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。")]),e._v(" "),v("p",[e._v("如果参数为空（或者为undefined和null），Object()返回一个空对象。")]),e._v(" "),v("p",[e._v("如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例。")]),e._v(" "),v("p",[e._v("如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。")]),e._v(" "),v("p",[e._v("Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。")]),e._v(" "),v("p",[e._v("Object构造函数的首要用途，是直接通过它来生成新对象。")]),e._v(" "),v("p",[e._v("Object.keys方法和Object.getOwnPropertyNames方法都用来遍历对象的属性。")]),e._v(" "),v("p",[e._v("Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。")]),e._v(" "),v("p",[e._v("对于一般的对象来说，Object.keys()和Object.getOwnPropertyNames()返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。Object.keys方法只返回可枚举的属性。")]),e._v(" "),v("p",[e._v("除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。")]),e._v(" "),v("p",[e._v("Object实例对象的方法，主要有以下六个。")]),e._v(" "),v("ul",[v("li",[e._v("Object.prototype.valueOf()：返回当前对象对应的值。")]),e._v(" "),v("li",[e._v("Object.prototype.toString()：返回当前对象对应的字符串形式。")]),e._v(" "),v("li",[e._v("Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。")]),e._v(" "),v("li",[e._v("Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。")]),e._v(" "),v("li",[e._v("Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。")]),e._v(" "),v("li",[e._v("Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。")])]),e._v(" "),v("p",[e._v("数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。")]),e._v(" "),v("h2",{attrs:{id:"包装对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#包装对象"}},[e._v("#")]),e._v(" 包装对象")]),e._v(" "),v("p",[e._v("对象是 JavaScript 语言最主要的数据类型，三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”（wrapper）。")]),e._v(" "),v("p",[e._v("所谓“包装对象”，指的是与数值、字符串、布尔值分别相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。")]),e._v(" "),v("p",[e._v("包装对象的设计目的，首先是使得“对象”这种类型可以覆盖 JavaScript 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法。")]),e._v(" "),v("p",[e._v("这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。")]),e._v(" "),v("p",[e._v("valueOf()方法返回包装对象实例对应的原始类型的值。")]),e._v(" "),v("p",[e._v("toString()方法返回对应的字符串形式。")]),e._v(" "),v("p",[e._v("某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。")]),e._v(" "),v("h3",{attrs:{id:"boolean-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#boolean-对象"}},[e._v("#")]),e._v(" Boolean 对象")]),e._v(" "),v("p",[e._v("Boolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。")]),e._v(" "),v("h3",{attrs:{id:"number-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#number-对象"}},[e._v("#")]),e._v(" Number 对象")]),e._v(" "),v("p",[e._v("Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。")]),e._v(" "),v("p",[e._v("Number对象拥有以下一些静态属性（即直接定义在Number对象上的属性，而不是定义在实例上的属性）。")]),e._v(" "),v("ul",[v("li",[e._v("Number.POSITIVE_INFINITY：正的无限，指向Infinity。")]),e._v(" "),v("li",[e._v("Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。")]),e._v(" "),v("li",[e._v("Number.NaN：表示非数值，指向NaN。")]),e._v(" "),v("li",[e._v("Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。")]),e._v(" "),v("li",[e._v("Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。")]),e._v(" "),v("li",[e._v("Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。")])]),e._v(" "),v("p",[e._v("Number对象部署了自己的toString方法，用来将一个数值转为字符串形式。")]),e._v(" "),v("p",[e._v("toFixed()方法先将一个数转为指定位数的小数。")]),e._v(" "),v("p",[e._v("toExponential方法用于将一个数转为科学计数法形式。")]),e._v(" "),v("p",[e._v("Number.prototype.toPrecision()方法用于将一个数转为指定位数的有效数字。")]),e._v(" "),v("p",[e._v("Number.prototype.toLocaleString()方法接受一个地区码作为参数，返回一个字符串，表示当前数字在该地区的当地书写形式。")]),e._v(" "),v("p",[e._v("与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。")]),e._v(" "),v("h3",{attrs:{id:"string-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#string-对象"}},[e._v("#")]),e._v(" String 对象")]),e._v(" "),v("p",[e._v("String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。")]),e._v(" "),v("p",[e._v("String对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。")]),e._v(" "),v("p",[e._v("String.prototype.length 字符串实例的length属性返回字符串的长度。")]),e._v(" "),v("p",[e._v("charAt方法返回指定位置的字符，参数是从0开始编号的位置。")]),e._v(" "),v("p",[e._v("charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。")]),e._v(" "),v("p",[e._v("concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。")]),e._v(" "),v("p",[e._v("slice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。")]),e._v(" "),v("p",[e._v("substring方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice方法很相像。")]),e._v(" "),v("p",[e._v("substr方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice和substring方法的作用相同。")]),e._v(" "),v("p",[e._v("indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。")]),e._v(" "),v("p",[e._v("lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。")]),e._v(" "),v("p",[e._v("trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。")]),e._v(" "),v("p",[e._v("toLowerCase方法用于将一个字符串全部转为小写，toUpperCase则是全部转为大写。它们都返回一个新字符串，不改变原字符串。")]),e._v(" "),v("p",[e._v("match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。")]),e._v(" "),v("p",[e._v("search方法的用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。")]),e._v(" "),v("p",[e._v("replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。")]),e._v(" "),v("p",[e._v("split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。")]),e._v(" "),v("p",[e._v("localeCompare方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。")]),e._v(" "),v("h2",{attrs:{id:"array-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#array-对象"}},[e._v("#")]),e._v(" Array 对象")]),e._v(" "),v("p",[e._v("Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。")]),e._v(" "),v("p",[e._v("Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。")]),e._v(" "),v("p",[e._v("Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。")]),e._v(" "),v("p",[e._v("valueOf方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。")]),e._v(" "),v("p",[e._v("toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。")]),e._v(" "),v("p",[e._v("push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。")]),e._v(" "),v("p",[e._v("pop方法用于删除数组的最后一个元素，并返回该元素。对空数组使用pop方法，不会报错，而是返回undefined。")]),e._v(" "),v("p",[e._v("shift()方法用于删除数组的第一个元素，并返回该元素。shift()方法可以遍历并清空一个数组。")]),e._v(" "),v("p",[e._v("unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。")]),e._v(" "),v("p",[e._v("join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。")]),e._v(" "),v("p",[e._v("concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。")]),e._v(" "),v("p",[e._v("reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。")]),e._v(" "),v("p",[e._v("slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。slice方法的一个重要应用，是将类似数组的对象转为真正的数组。")]),e._v(" "),v("p",[e._v("splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。")]),e._v(" "),v("p",[e._v("sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。")]),e._v(" "),v("p",[e._v("如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。")]),e._v(" "),v("p",[e._v("map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回")]),e._v(" "),v("p",[e._v("forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。")]),e._v(" "),v("p",[e._v("filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。")]),e._v(" "),v("p",[e._v("它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。")]),e._v(" "),v("p",[e._v("indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。")]),e._v(" "),v("h2",{attrs:{id:"json-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#json-对象"}},[e._v("#")]),e._v(" JSON 对象")]),e._v(" "),v("p",[e._v("JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。")]),e._v(" "),v("p",[e._v("JSON 对值的类型和格式有严格的规定：")]),e._v(" "),v("ul",[v("li",[e._v("复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。")]),e._v(" "),v("li",[e._v("原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。")]),e._v(" "),v("li",[e._v("字符串必须使用双引号表示，不能使用单引号。")]),e._v(" "),v("li",[e._v("对象的键名必须放在双引号里面。")]),e._v(" "),v("li",[e._v("数组或对象最后一个成员的后面，不能加逗号。")])]),e._v(" "),v("p",[e._v("JSON对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：JSON.stringify()和JSON.parse()。")]),e._v(" "),v("h3",{attrs:{id:"json-stringify"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#json-stringify"}},[e._v("#")]),e._v(" JSON.stringify()")]),e._v(" "),v("p",[e._v("JSON.stringify方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。")]),e._v(" "),v("p",[e._v("注意，对于原始类型的字符串，转换结果会带双引号。")]),e._v(" "),v("p",[e._v("如果对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify过滤。")]),e._v(" "),v("p",[e._v("如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。")]),e._v(" "),v("p",[e._v("正则对象会被转成空对象。")]),e._v(" "),v("p",[e._v("JSON.stringify方法会忽略对象的不可遍历的属性。")]),e._v(" "),v("p",[e._v("JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。")]),e._v(" "),v("p",[e._v("第二个参数还可以是一个函数，用来更改JSON.stringify的返回值。")]),e._v(" "),v("p",[e._v("JSON.stringify还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。")]),e._v(" "),v("p",[e._v("如果参数对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。")]),e._v(" "),v("h3",{attrs:{id:"json-parse"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#json-parse"}},[e._v("#")]),e._v(" JSON.parse()")]),e._v(" "),v("p",[e._v("JSON.parse方法用于将 JSON 字符串转换成对应的值。")]),e._v(" "),v("p",[e._v("如果传入的字符串不是有效的 JSON 格式，JSON.parse方法将报错。")]),e._v(" "),v("p",[e._v("为了处理解析错误，可以将JSON.parse方法放在try...catch代码块中。")]),e._v(" "),v("p",[e._v("JSON.parse方法可以接受一个处理函数，作为第二个参数，用法与JSON.stringify方法类似。")]),e._v(" "),v("h2",{attrs:{id:"set"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[e._v("#")]),e._v(" Set")]),e._v(" "),v("p",[e._v("它类似于数组，但是成员的值都是唯一的，没有重复的值。")]),e._v(" "),v("p",[e._v("Set本身是一个构造函数，用来生成 Set 数据结构。")]),e._v(" "),v("p",[e._v("Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。")]),e._v(" "),v("p",[e._v("Set 结构的实例有以下属性。")]),e._v(" "),v("ul",[v("li",[e._v("Set.prototype.constructor：构造函数，默认就是Set函数。")]),e._v(" "),v("li",[e._v("Set.prototype.size：返回Set实例的成员总数。")])]),e._v(" "),v("p",[e._v("Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。")]),e._v(" "),v("ul",[v("li",[e._v("Set.prototype.add(value)：添加某个值，返回 Set 结构本身。")]),e._v(" "),v("li",[e._v("Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。")]),e._v(" "),v("li",[e._v("Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。")]),e._v(" "),v("li",[e._v("Set.prototype.clear()：清除所有成员，没有返回值。")])]),e._v(" "),v("p",[e._v("Set 结构的实例有四个遍历方法，可以用于遍历成员。")]),e._v(" "),v("ul",[v("li",[e._v("Set.prototype.keys()：返回键名的遍历器")]),e._v(" "),v("li",[e._v("Set.prototype.values()：返回键值的遍历器")]),e._v(" "),v("li",[e._v("Set.prototype.entries()：返回键值对的遍历器")]),e._v(" "),v("li",[e._v("Set.prototype.forEach()：使用回调函数遍历每个成员\nSet的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。")])]),e._v(" "),v("p",[e._v("由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。")]),e._v(" "),v("p",[e._v("如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。")]),e._v(" "),v("h2",{attrs:{id:"weakset"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#weakset"}},[e._v("#")]),e._v(" WeakSet")]),e._v(" "),v("p",[e._v("WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。")]),e._v(" "),v("p",[e._v("首先，WeakSet 的成员只能是对象，而不能是其他类型的值。其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。")]),e._v(" "),v("p",[e._v("WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。")]),e._v(" "),v("p",[e._v("作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。")]),e._v(" "),v("p",[e._v("WeakSet 没有size属性，没有办法遍历它的成员。")]),e._v(" "),v("p",[e._v("WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。")]),e._v(" "),v("h2",{attrs:{id:"map"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[e._v("#")]),e._v(" Map")]),e._v(" "),v("p",[e._v("JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。")]),e._v(" "),v("p",[e._v("为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。")]),e._v(" "),v("p",[e._v("也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。")]),e._v(" "),v("p",[e._v("Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。")]),e._v(" "),v("p",[e._v("size属性返回 Map 结构的成员总数。")]),e._v(" "),v("p",[e._v("Map.prototype.set(key, value)方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是当前的Map对象，因此可以采用链式写法。")]),e._v(" "),v("p",[e._v("Map.prototype.get(key)方法读取key对应的键值，如果找不到key，返回undefined。")]),e._v(" "),v("p",[e._v("Map 结构原生提供三个遍历器生成函数和一个遍历方法。")]),e._v(" "),v("ul",[v("li",[e._v("Map.prototype.keys()：返回键名的遍历器。")]),e._v(" "),v("li",[e._v("Map.prototype.values()：返回键值的遍历器。")]),e._v(" "),v("li",[e._v("Map.prototype.entries()：返回所有成员的遍历器。")]),e._v(" "),v("li",[e._v("Map.prototype.forEach()：遍历 Map 的所有成员。\n需要特别注意的是，Map 的遍历顺序就是插入顺序。")])]),e._v(" "),v("h2",{attrs:{id:"weakmap"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#weakmap"}},[e._v("#")]),e._v(" WeakMap")]),e._v(" "),v("p",[e._v("WeakMap结构与Map结构类似，也是用于生成键值对的集合。")]),e._v(" "),v("p",[e._v("首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。")]),e._v(" "),v("p",[e._v("其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。")]),e._v(" "),v("p",[e._v("如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。WeakMap 的另一个用处是部署私有属性。")]),e._v(" "),v("p",[e._v("WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。")])])}),[],!1,null,null,null);t.default=a.exports}}]);