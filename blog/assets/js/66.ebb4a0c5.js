(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{311:function(e,a,s){"use strict";s.r(a);var t=s(28),r=Object(t.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"_4-1-koa-简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-koa-简介"}},[e._v("#")]),e._v(" 4_1 koa 简介")]),e._v(" "),s("p",[e._v("本节我们将简单介绍一下 koa。")]),e._v(" "),s("h2",{attrs:{id:"nodejs是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nodejs是什么？"}},[e._v("#")]),e._v(" nodejs是什么？")]),e._v(" "),s("p",[e._v("Node.js是一个创建于 2009年的Javascript运行环境。它使用了一个事件驱动、非阻塞式 I/O 的模型，基于回调实现的异步编程，使其轻量又高效。")]),e._v(" "),s("p",[e._v("例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。")]),e._v(" "),s("p",[e._v("这就大大提高了 Node.js 的性能，可以处理大量的并发请求，因此，Node 主要用在开发 Web 应用。")]),e._v(" "),s("h2",{attrs:{id:"使用原生nodejs提供web服务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用原生nodejs提供web服务"}},[e._v("#")]),e._v(" 使用原生nodejs提供web服务")]),e._v(" "),s("p",[e._v("要在nodejs中提供web服务，我们需要引入 nodejs 的Http模块:require('http'), 然后调用createServer方法，传入一个函数作为参数即可：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const Server = http.createServer((req, res) => {\n  res.writeHead(200,{'Content-Type': 'application/json;charset=utf-8;'});\n  res.write('{text: \"写代码很快乐啊!\"}');\n  res.end();\n}).listen(8888)；\n")])])]),s("p",[e._v("可以看到，代码可读性不是很好，开发也不是很便利，于是就有了 Express 这个第一代最流行的web框架。")]),e._v(" "),s("h2",{attrs:{id:"express-框架"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#express-框架"}},[e._v("#")]),e._v(" express 框架")]),e._v(" "),s("p",[e._v("我们看看，使用express， 怎么实现一个最简单的入门网站：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var express = require('express');\nvar app = express();\napp.get('/', function (req, res) {\n    res.send('写代码很快乐!');\n});\napp.listen(8888);\n")])])]),s("p",[e._v("可以看到，代码精简了很多，虽然express的API很简单，但是它是基于ES5的语法，要实现异步代码，只有一个方法：回调。如果异步嵌套层次过多，代码写起来就非常难看，比如读取一个文件成功后再读取一个文件：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("app.get('/file', function (req, res) {\n    fs.readFile('/file1', function (err, data) {\n        if (err) { res.status(500).send('读取文件1失败'); }\n        fs.readFile('/file2', function (err, data) {\n            if (err) {  res.status(500).send('读取文件2失败'); }\n            res.type('text/plain');\n            res.send(data);\n        });\n    });\n});\n")])])]),s("p",[e._v("虽然可以用async这样的库来组织异步代码，但是用回调写异步实在是太痛苦了，特别是异步嵌套多的时候，这就是JS远古时期的 回调地狱！")]),e._v(" "),s("h2",{attrs:{id:"koa-1-x的到来"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#koa-1-x的到来"}},[e._v("#")]),e._v(" koa 1.x的到来")]),e._v(" "),s("p",[e._v("随着ES6在新版Node.js获得支持ES6，express的团队基于ES6的generator推出了koa这个 web 框架。和express相比，koa 1.0使用generator实现异步，比如实现上面同样的功能，代码如下：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var koa = require('koa');\nvar app = koa();\n\napp.use('/file', function *() {\n    yield readFile1();\n    var data = yield readFile2();\n    this.body = data;\n});\napp.listen(8888);\n")])])]),s("p",[e._v("可以看到，用generator实现异步比回调简单了不少，但是generator的本意并不是异步。Promise才是为异步设计的，但是Promise的写法很复杂。为了简化异步代码，ES7引入了新的关键字async和await，可以轻松地把一个function变为异步模式：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("async function () {\n    var data = await fs.read('/file1');\n}\n")])])]),s("h2",{attrs:{id:"最新的koa-2-x的到来"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最新的koa-2-x的到来"}},[e._v("#")]),e._v(" 最新的koa 2.x的到来")]),e._v(" "),s("p",[e._v("koa团队并没有止步于koa 1.0，他们非常超前地基于ES7开发了koa2，和koa 1相比，koa2完全使用Promise并配合async来实现异步。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("app.use(async (ctx, next) => {\n    await next();\n    var data = await readFile();\n    ctx.response.type = 'text/plain';\n    ctx.response.body = data;\n});\n")])])]),s("p",[e._v("通过以上分享，大家可以看到，我们项目使用koa2，是按照node->express->koa1-<koa2 一步步随着新的JS规范通过并获得支持的发展而来的，出现的主要原因就是为了在node开发中优雅的写异步代码。")]),e._v(" "),s("h2",{attrs:{id:"express-koa1和koa2的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#express-koa1和koa2的区别"}},[e._v("#")]),e._v(" express, koa1和koa2的区别")]),e._v(" "),s("h3",{attrs:{id:"koa-vs-express"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#koa-vs-express"}},[e._v("#")]),e._v(" koa vs express")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("相同点")]),e._v(" "),s("ul",[s("li",[e._v("构建 web 应用的 node 框架")]),e._v(" "),s("li",[e._v("总体来看语法差别不大，比如都是引入后框架后实例后，中间件处理以及监听端口；")]),e._v(" "),s("li",[e._v("都是同一个团队开发维护的")])])]),e._v(" "),s("li",[s("p",[e._v("区别")]),e._v(" "),s("ul",[s("li",[e._v("express: 框架内容更丰富，有更大的社区，历史更悠久，文档更丰富，用户群更大，支持 jade 等前端模板语言，express没有统一的错误处理，而koa有默认的错误处理方式。")]),e._v(" "),s("li",[e._v("koa: 更小、更富有表现力、更健壮，"),s("em",[s("strong",[e._v("Koa 支持 es6 语法")])]),e._v("，Koa 在内核方法中不绑定任何中间件，不提供路由功能和某些工具，摒弃了的回调，采用 generator 或 promise的方式，在 Context中，Koa 对 request 和 response 进行了封装，使用方式也相应改变，如返回简单内容，在koa: this.body = ‘hello world’，而在express: res.send(‘hello world’)。")])])])]),e._v(" "),s("h3",{attrs:{id:"koa1-vs-koa2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#koa1-vs-koa2"}},[e._v("#")]),e._v(" koa1 vs koa2")]),e._v(" "),s("ul",[s("li",[e._v("中间件的使用:  koa1依赖 co 并采用 generator 函数，在函数内使用 yield 语句，而koa2增加了箭头函数，移除了 co 依赖，使用 Promise，因此可以结合 async，await 使用；")]),e._v(" "),s("li",[e._v("context 对象的获取：koa1为this 对象，this.req, this.res；koa2: cxt 参数，cxt.req, cxt.res。")])]),e._v(" "),s("p",[e._v("了解了koa的背景知识后，下一节我们将简单分析其源码啦！")])])}),[],!1,null,null,null);a.default=r.exports}}]);